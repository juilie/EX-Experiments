<!DOCTYPE html>
<html lang="en">
	<head>
		<title>EX Research</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<link rel="stylesheet" href="https://unpkg.com/7.css">
		<style>

			@font-face {
				font-family: 'ff7';
				src: url('assets/Final_Fantasy_VII.ttf') format('truetype');
			}

			html, body {
				margin: 0;
				padding: 0;
				overflow: hidden;
				width: 100%;
				height: 100%;
			}
			
			#homepage-ui {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				z-index: 200;
				pointer-events: none;
				font-family: 'Arial Narrow', monospace;
			}

			.agency-card {
				max-width: 520px;
				width: 92%;
				pointer-events: auto;
				/* animation: cardPopIn 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards; */
				/* transform: scale(0); */
				/* animation-delay: 0.2s; */
				background: #ffffff;
				border: 1px solid #101010;
				border-radius: 10px;
				position: relative;
				overflow: hidden;
				box-shadow: 0 12px 30px rgba(0,0,0,0.25), 0 2px 8px rgba(0,0,0,0.15);
			}

			/* Pixel-styled window variant */
			.agency-card.pixel-window {
				border-radius: 4px;
				image-rendering: pixelated;
				box-shadow:
					0 0 0 2px #000,
					0 0 0 4px #7aa7d9,
					0 0 0 6px #000,
					6px 6px 0 #00000020,
					12px 12px 0 #00000015; /* maximal stepped frame */
			}

			.agency-card.pixel-window::after {
				content: '';
				position: absolute;
				inset: 0;
				pointer-events: none;
				background:
					repeating-linear-gradient(90deg, transparent 0 3px, rgba(0,0,0,0.02) 3px 4px),
					repeating-linear-gradient(0deg, transparent 0 3px, rgba(0,0,0,0.02) 3px 4px);
				opacity: .7; /* light pixel grid texture */
			}

			/* animated scanlines overlay */
			.window-scanlines {
				position: absolute;
				inset: 41px 0 22px 0; /* inside title and status bars */
				pointer-events: none;
				background: repeating-linear-gradient(0deg, rgba(0,0,0,0.06) 0 1px, transparent 1px 3px);
				animation: scanMove 4s linear infinite;
				opacity: .35;
			}

			@keyframes scanMove { 0% { background-position-y: 0; } 100% { background-position-y: 8px; } }

			/* disable previous decorative tabs */
			.agency-card::before,
			.agency-card::after { display: none; }

			/* Generic app window title bar */
			.window-titlebar {
				height: 40px;
				background: linear-gradient(to bottom, #e9eef3, #cfd6de);
				border-bottom: 2px solid #000;
				display: flex;
				align-items: center;
				justify-content: space-between;
				padding: 0 0 0 10px;
				box-shadow: inset 0 -2px 0 #7aa7d9, inset 0 2px 0 #ffffff;
			}

			/* 3D title canvas container */
			#three-title {
				width: 100%;
				height: 170px;
				position: relative;
				margin: 4px 0 6px 0;
			}
			#three-title canvas { display: block; width: 100%; height: 100%;
				filter: drop-shadow(0px 0px 10px black); }

			.window-title {
				font-size: 12px;
				font-weight: 600;
				letter-spacing: 0.08em;
				text-transform: uppercase;
				color: #1d2935;
				text-shadow: 0 1px 0 #fff;
			}

			.window-controls {
				display: flex;
				gap: 6px;
				padding: 0 10px;
			}

			.window-control {
				width: 16px;
				height: 16px;
				border: 1px solid #2a2a2a;
				border-radius: 2px;
				background: #ffffff;
				display: grid;
				place-items: center;
				cursor: default;
				box-shadow: inset 0 -1px 0 #d5dbe3, inset 0 1px 0 #ffffff;
			}

			.window-control span {
				font-size: 10px;
				line-height: 1;
				color: #333;
			}

			.window-control:hover { background: #eef3f8; }
			.window-control:active { border-color: #111; }

			/* colored pixel controls */
			/* Neutral minimize/resize by default; Close turns red on hover */
			.window-control[title="Close"]:hover { background: #f1d4d6; }
			.window-control[title="Close"]:active { background: #e9b3b8; }

			/* Toolbar chips and address bar */
			.window-toolbar {
				display: flex;
				align-items: center;
				gap: 8px;
				padding: 8px 10px;
				border-bottom: 2px solid #000;
				background: linear-gradient(#ffffff,#f4f6f8);
				color: #323232;
			}

			.toolbar-chip {
				padding: 2px 6px;
				font-size: 10px;
				border: 1px solid #000;
				border-radius: 3px;
				background: #e9eef3;
				box-shadow: 1px 1px 0 #000;
			}

			.address-bar {
				flex: 1;
				height: 20px;
				border: 1px solid #000;
				border-radius: 3px;
				background: #ffffff;
				box-shadow: inset 1px 1px 0 #dcdcdc;
			}

			/* Status bar */
			.status-bar {
				height: 22px;
				display: flex;
				align-items: center;
				justify-content: space-between;
				gap: 10px;
				padding: 0 8px;
				border-top: 2px solid #000;
				background: repeating-linear-gradient(90deg, #e7eef6 0 6px, #dfe7f0 6px 12px);
				font-size: 10px;
				color: #1d2935;
			}

			.card-header { display: none; }

			.card-title {
				font-size: 12px;
				font-weight: 500;
				color: #666;
				text-transform: uppercase;
				letter-spacing: 2px;
				margin: 0;
				text-align: center;
			}

			.card-body {
				padding: 36px;
				padding-top: 0px;
				text-align: center;
				background: url('./assets/images/cloud2.png') no-repeat center center;
				background-size: cover;
			}

			#enter-button {
				background: #c0c0c0; /* classic gray */
				color: #000000;
				padding: 12px 28px;
				font-size: 14px;
				font-weight: 700;
				letter-spacing: 0.02em;
				text-transform: none;
				border-radius: 0;
				cursor: pointer;
				position: relative;
				border: 2px solid #ffffff; /* top/left light */
				border-right-color: #404040; /* right dark */
				border-bottom-color: #404040; /* bottom dark */
				box-shadow:
					inset 1px 1px 0 #dfdfdf,
					inset -1px -1px 0 #808080,
					0 0 0 1px #000000; /* outer black keyline like old UI */
				transition: background-color .12s ease;
			}

			#enter-button:hover {
				background: #dcdcdc;
			}

			#enter-button:active {
				background: #b5b5b5;
				border-color: #404040; /* top/left dark when pressed */
				border-right-color: #ffffff; /* right/bottom light when pressed */
				border-bottom-color: #ffffff;
				box-shadow:
					inset -1px -1px 0 #dfdfdf,
					inset 1px 1px 0 #808080,
					0 0 0 1px #000000;
			}

			#enter-button:focus {
				outline: 1px dotted #000000;
				outline-offset: 2px;
			}
			
			#main-title {
				font-size: 60px;
				font-weight: 300;
				color: #000000;
				margin: 0 0 24px 0;
				font-family: 'Arial Narrow', monospace;
				line-height: 1.1;
				display: flex;
				align-items: baseline;
				justify-content: center;
				flex-wrap: wrap;
				letter-spacing: -1px;
			}

			.letter {
				display: inline-block;
				transition: transform 0.3s ease;
			}

			.letter.small {
				font-size: 0.6em;
				font-weight: normal;
			}

			.letter.medium {
				font-size: 0.8em;
				font-weight:900;
			}
			.letter.medium-light {
				font-size: 0.8em;
				font-weight:100;
			}

			.letter.big {
				font-size: 1em;
				font-weight: 900;
			}

			.letter.huge {
				font-size: 1.3em;
				font-weight: 900;
			}

			@keyframes cardPopIn {
				0% {
					transform: scale(0) rotateY(-10deg);
					opacity: 0;
				}
				50% {
					transform: scale(1.05) rotateY(0deg);
					opacity: 1;
				}
				100% {
					transform: scale(1) rotateY(0deg);
					opacity: 1;
				}
			}
			
			#subtitle {
				font-size: 20px;
				color: black;
				margin: 0 0 32px 0;
				line-height: 1.5;
				font-weight: 600;
				margin-top: -64px;
				text-shadow: 
					2px 2px 4px rgba(255,255,255,0.8),
					0 0 8px rgba(255,255,255,0.6),
					0 0 16px rgba(255,255,255,0.4);
				background: rgba(199, 199, 199, 0.61);
				padding: 8px 16px;
				border: inset 2px lightgray;
				backdrop-filter: blur(4px);
			}
			
			.hidden {
				display: none !important;
			}
			
			.cloud-image {
				position: fixed;
				z-index: 150;
				pointer-events: none;
				transform-origin: center center;
				opacity: 1;
				filter: brightness(1.1) contrast(1.1);
			}
			
			.hud-scanner {
				position: fixed;
				width: 20px;
				height: 20px;
				border: 2px solid #4a90e2;
				background: rgba(74, 144, 226, 0.15);
				z-index: 160;
				pointer-events: none;
				transition: all 0.4s ease;
				box-shadow: 
					0 0 8px rgba(74, 144, 226, 0.4),
					inset 0 0 8px rgba(74, 144, 226, 0.2);
			}
			
			.hud-scanner.scanning {
				border-color: #2ecc71;
				background: rgba(46, 204, 113, 0.15);
				box-shadow: 
					0 0 15px rgba(46, 204, 113, 0.6),
					inset 0 0 10px rgba(46, 204, 113, 0.3);
			}
			
			.hud-scanner::before {
				content: '';
				position: absolute;
				top: 50%;
				left: 50%;
				width: 6px;
				height: 6px;
				background: currentColor;
				border-radius: 50%;
				transform: translate(-50%, -50%);
				box-shadow: 0 0 4px currentColor;
			}
			
			.hud-scanner::after {
				content: attr(data-status);
				position: absolute;
				bottom: -35px;
				right: -50px;
				font-family: 'Epmarugo', monospace;
				font-size: 10px;
				color: black;
				white-space: nowrap;
				font-weight: bold;
				text-shadow: 1px 1px 0px white, -1px -1px 0px white, 1px -1px 0px white, -1px 1px 0px white;
			}
			

			.hud-scanner-frame {
				position: absolute;
				top: -3px;
				left: -3px;
				right: -3px;
				bottom: -3px;
				border: 1px solid currentColor;
				opacity: 0.6;
				pointer-events: none;
			}
			
			.hud-scanner-corners {
				position: absolute;
				top: -6px;
				left: -6px;
				right: -6px;
				bottom: -6px;
				pointer-events: none;
			}
			
			.hud-scanner-corners::before,
			.hud-scanner-corners::after {
				content: '';
				position: absolute;
				width: 8px;
				height: 8px;
				border: 1px solid black;
				opacity: 0.8;
			}
			
			.hud-scanner-corners::before {
				top: 0;
				left: 0;
				border-right: none;
				border-bottom: none;
			}
			
			.hud-scanner-corners::after {
				bottom: 0;
				right: 0;
				border-left: none;
				border-top: none;
			}
		</style>
	</head>
	<body>
		<div id="homepage-ui">
			<div class="agency-card pixel-window">
				<div class="window-titlebar">
					<div class="window-title">EX Research</div>
					<div class="window-controls">
						<div class="window-control" title="Minimize"><span>–</span></div>
						<div class="window-control" title="Resize"><span>□</span></div>
						<div class="window-control" title="Close"><span>×</span></div>
					</div>
				</div>
				<div class="window-toolbar">
					<div class="toolbar-chip">EX</div>
					<div class="toolbar-chip">research</div>
					<div class="toolbar-chip">labs</div>
					<div class="address-bar"></div>
				</div>
				<div class="card-body">
					<div id="three-title" aria-label="EX Research"></div>
					<p id="subtitle">The world's most online agency.</p>
					<button id="enter-button">ENTER</button>
				</div>
				<div class="window-scanlines"></div>
				<div class="status-bar">
					<span>Website v1.0</span>
					<span>Connected...</span>
				</div>
			</div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';
			import { FontLoader } from 'three/addons/loaders/FontLoader.js';
			import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

			import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
			import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
			import { SAOPass } from 'three/addons/postprocessing/SAOPass.js';
			import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
			import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

			let container, stats;
			let camera, scene, renderer;
			let composer, renderPass, saoPass, ditheringPass;
			let group;
			// Color scheme controls
			let colorSchemes, colorSchemeNames, colorControls;
			// 3D title
			let titleRenderer, titleScene, titleCamera, titleMesh, titleMount, exMesh, researchMesh;
			// Background pixelation animation controls
			const pixelationAnim = {
				enabled: false, // disabled to keep orbs smooth
				minScale: 0.12, // much lower internal resolution
				maxScale: 0.12, // keep constant (no resolution pulsing)
				speedHz: 0.0,
				lastW: 0,
				lastH: 0
			};
			
			// 2D Chatbox overlay variables
			let overlayCanvas, overlayCtx;
			let chatboxes2D = [];
			let customFontLoaded = false;
			let lastSpawnTime = 0;
			let spawnInterval = 1200; // Spawn new chatbox every 1.2 seconds (faster spawning)
			let pixelScale = 2; // How much to scale down for pixelation (higher = more pixelated)
			
			// Homepage elements
			let showHomepageUI = true;
			let enterButtonHovered = false;
			
			// Cloud image system
			let cloudImages = [];
			let lastCloudSpawnTime = 0; // Start at 0 so first cloud spawns immediately
			let cloudSpawnInterval = 3000; // Spawn every 3 seconds
			
			// Wandering HUD scanner system
			let wanderingScanners = [];
			let maxScanners = 3; // Number of autonomous scanners
			let detectionDistance = 80; // Distance at which scanners detect images
			
			// Intro sequence variables (disabled)
			let introStartTime = 0;
			let introPhase = 'normal'; // Start directly in normal mode
			let introDuration = 0; // No flooding
			let stragglerDuration = 0; // No stragglers
			let transitionDuration = 0; // No transition

			// Dithering shader
			const DitheringShader = {
				uniforms: {
					'tDiffuse': { value: null },
					'resolution': { value: new THREE.Vector2() },
					'colorNum': { value: 4.0 },
					'pixelSize': { value: 2.0 }
				},

				vertexShader: `
					varying vec2 vUv;
					void main() {
						vUv = uv;
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					}
				`,

				fragmentShader: `
					uniform sampler2D tDiffuse;
					uniform vec2 resolution;
					uniform float colorNum;
					uniform float pixelSize;
					varying vec2 vUv;

					const float bayerMatrix8x8[64] = float[64](
						0.0/ 64.0, 48.0/ 64.0, 12.0/ 64.0, 60.0/ 64.0,  3.0/ 64.0, 51.0/ 64.0, 15.0/ 64.0, 63.0/ 64.0,
						32.0/ 64.0, 16.0/ 64.0, 44.0/ 64.0, 28.0/ 64.0, 35.0/ 64.0, 19.0/ 64.0, 47.0/ 64.0, 31.0/ 64.0,
						8.0/ 64.0, 56.0/ 64.0,  4.0/ 64.0, 52.0/ 64.0, 11.0/ 64.0, 59.0/ 64.0,  7.0/ 64.0, 55.0/ 64.0,
						40.0/ 64.0, 24.0/ 64.0, 36.0/ 64.0, 20.0/ 64.0, 43.0/ 64.0, 27.0/ 64.0, 39.0/ 64.0, 23.0/ 64.0,
						2.0/ 64.0, 50.0/ 64.0, 14.0/ 64.0, 62.0/ 64.0,  1.0/ 64.0, 49.0/ 64.0, 13.0/ 64.0, 61.0/ 64.0,
						34.0/ 64.0, 18.0/ 64.0, 46.0/ 64.0, 30.0/ 64.0, 33.0/ 64.0, 17.0/ 64.0, 45.0/ 64.0, 29.0/ 64.0,
						10.0/ 64.0, 58.0/ 64.0,  6.0/ 64.0, 54.0/ 64.0,  9.0/ 64.0, 57.0/ 64.0,  5.0/ 64.0, 53.0/ 64.0,
						42.0/ 64.0, 26.0/ 64.0, 38.0/ 64.0, 22.0/ 64.0, 41.0/ 64.0, 25.0/ 64.0, 37.0/ 64.0, 21.0 / 64.0
					);

					vec3 dither(vec2 uv, vec3 color) {
						int x = int(uv.x * resolution.x) % 8;
						int y = int(uv.y * resolution.y) % 8;
						float threshold = bayerMatrix8x8[y * 8 + x] - 0.25;

						color.rgb += threshold;
						color.r = floor(color.r * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);
						color.g = floor(color.g * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);
						color.b = floor(color.b * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);

						return color;
					}

					void main() {
						vec2 normalizedPixelSize = pixelSize / resolution;  
						vec2 uvPixel = normalizedPixelSize * floor(vUv / normalizedPixelSize);

						vec4 color = texture2D(tDiffuse, uvPixel);
						color.rgb = dither(uvPixel, color.rgb);

						gl_FragColor = color;
					}
				`
			};

			function createOverlayCanvas() {
				overlayCanvas = document.createElement('canvas');
				overlayCanvas.style.position = 'fixed'; // Use fixed instead of absolute
				overlayCanvas.style.top = '0';
				overlayCanvas.style.left = '0';
				overlayCanvas.style.pointerEvents = 'none';
				overlayCanvas.style.zIndex = '100';
				overlayCanvas.style.imageRendering = 'pixelated'; // Crisp pixel scaling
				overlayCanvas.style.imageRendering = 'crisp-edges'; // Fallback
				overlayCanvas.style.overflow = 'hidden'; // Prevent any overflow
				document.body.appendChild(overlayCanvas);
				
				overlayCtx = overlayCanvas.getContext('2d');
				// Disable antialiasing for crisp pixels
				overlayCtx.imageSmoothingEnabled = false;
				overlayCtx.webkitImageSmoothingEnabled = false;
				overlayCtx.mozImageSmoothingEnabled = false;
				overlayCtx.msImageSmoothingEnabled = false;
				
				resizeOverlayCanvas();
				
				// Load custom font
				loadCustomFont();
				
				// Create 2D chatboxes
				create2DChatboxes();
				
				// Setup homepage UI
				setupHomepageUI();
			}

			function loadCustomFont() {
				const font = new FontFace('Epmarugo', 'url(assets/epmarugo.ttf)');
				font.load().then(function(loadedFont) {
					document.fonts.add(loadedFont);
					customFontLoaded = true;
				}).catch(function(error) {
					console.warn('Custom font failed to load:', error);
					customFontLoaded = false;
				});
			}

			function resizeOverlayCanvas() {
				// Use viewport dimensions that exclude scrollbars
				const viewportWidth = document.documentElement.clientWidth;
				const viewportHeight = document.documentElement.clientHeight;
				
				// Set actual canvas size to lower resolution
				overlayCanvas.width = Math.floor(viewportWidth / pixelScale);
				overlayCanvas.height = Math.floor(viewportHeight / pixelScale);
				
				// Scale up the canvas display size to exact viewport
				overlayCanvas.style.width = viewportWidth + 'px';
				overlayCanvas.style.height = viewportHeight + 'px';
			}


			function setupHomepageUI() {
				const homepageUI = document.getElementById('homepage-ui');
				const enterButton = document.getElementById('enter-button');
				
				if (enterButton) {
					enterButton.addEventListener('click', function() {
						// Hide homepage UI
						window.location.href = '/articles/index.html';
					});
				}
			}

			function create2DChatboxes() {
				// Start with some initial chatboxes already on screen
				chatboxes2D = [];
				
				// Create 8-12 initial chatboxes spread around the screen
				const initialCount = 8 + Math.floor(Math.random() * 5); // 8-12 chatboxes
				
				for (let i = 0; i < initialCount; i++) {
					const chatbox = createNewChatbox();
					// Better distribution - spread them more evenly across the screen
					const gridCols = Math.ceil(Math.sqrt(initialCount));
					const gridRows = Math.ceil(initialCount / gridCols);
					const col = i % gridCols;
					const row = Math.floor(i / gridCols);
					
					// Add some randomness to the grid positions
					const cellWidth = (overlayCanvas.width / pixelScale) / gridCols;
					const cellHeight = (overlayCanvas.height / pixelScale) / gridRows;
					
					chatbox.x = (col * cellWidth) + (Math.random() * cellWidth * 0.8);
					chatbox.y = (row * cellHeight) + (Math.random() * cellHeight * 0.8);
					
					// Make sure they stay within bounds
					chatbox.x = Math.max(0, Math.min(chatbox.x, overlayCanvas.width / pixelScale - chatbox.width));
					chatbox.y = Math.max(0, Math.min(chatbox.y, overlayCanvas.height / pixelScale - chatbox.height));
					
					chatboxes2D.push(chatbox);
				}
				
				console.log(`Created ${initialCount} initial chatboxes`);
			}

			function createNewChatbox(startX = null, speedTier = 'normal') {
				// Base dimensions that will appear consistent on screen regardless of pixelation
				const baseWidth = 240; // Target screen width in pixels
				const baseHeight = 72; // Target screen height in pixels
				
				// Scale dimensions inversely with pixelation to maintain consistent screen size
				const scaledWidth = baseWidth / pixelScale;
				const scaledHeight = baseHeight / pixelScale;
				const scaledMargin = 80 / pixelScale;
				
				const x = startX !== null ? startX : overlayCanvas.width + scaledMargin/4;
				const caretMargin = 20 / pixelScale; // medium margin only for caret
				const y = Math.random() * (overlayCanvas.height - scaledHeight - caretMargin);
				
				// Different speeds based on tier
				let baseVelocity, verticalDrift;
				switch (speedTier) {
					case 'superfast':
						// Lightning fast - the main rush
						baseVelocity = (-5 - Math.random() * 6) / pixelScale; // 5-11x faster
						verticalDrift = ((Math.random() - 0.5) * 1.5) / pixelScale; // Lots of vertical chaos
						break;
					case 'fast':
						// Fast but not crazy - part of the flood
						baseVelocity = (-3 - Math.random() * 3) / pixelScale; // 3-6x faster
						verticalDrift = ((Math.random() - 0.5) * 1.0) / pixelScale; // Some vertical movement
						break;
					case 'medium':
						// Medium speed - stragglers
						baseVelocity = (-1.5 - Math.random() * 2) / pixelScale; // 1.5-3.5x faster
						verticalDrift = ((Math.random() - 0.5) * 0.6) / pixelScale; // Moderate vertical
						break;
					case 'slow':
						// Slow stragglers - bridge to normal
						baseVelocity = (-0.8 - Math.random() * 1.2) / pixelScale; // 0.8-2x faster
						verticalDrift = ((Math.random() - 0.5) * 0.4) / pixelScale; // Little vertical
						break;
					default: // 'normal'
						// Normal mode: regular speed
						baseVelocity = (-0.5 - Math.random() * 0.8) / pixelScale;
						verticalDrift = ((Math.random() - 0.5) * 0.2) / pixelScale;
						break;
				}
				
				return {
					x: x,
					y: y,
					vx: baseVelocity,
					vy: verticalDrift,
					width: scaledWidth,
					height: scaledHeight,
					text: 'EX Research',
					textStyles: generateRandomTextStyles(), // Random styling for each chatbox
					styleUpdateTime: 0, // Track when to update styling
					speedTier: speedTier // Track what tier this chatbox is
				};
			}

			function generateRandomTextStyles() {
				// Simple "EX Research" with random styling
				const fragments = [
					{
						text: 'EX',
						bold: Math.random() > 0.5,
						sizeMultiplier: 0.8 + Math.random() * 0.6 // 0.8x to 1.4x size
					},
					{
						text: ' ',
						bold: false,
						sizeMultiplier: 1
					},
					{
						text: 'Research',
						bold: Math.random() > 0.5,
						sizeMultiplier: 0.8 + Math.random() * 0.6
					}
				];
				return fragments;
			}

			function createCloudImage() {
				const exNumber = Math.floor(Math.random() * 9) + 1; // 1-9
				const img = document.createElement('img');
				img.src = `assets/ex${exNumber}.png`;
				img.className = 'cloud-image';
				
				console.log(`Creating cloud image: ${img.src}`);
				
				// Random position
				const x = Math.random() * (window.innerWidth - 200) + 100;
				const y = Math.random() * (window.innerHeight - 200) + 100;
				
				// Random final size (ignoring aspect ratio)
				const finalWidth = 150 + Math.random() * 300; // 150-450px
				const finalHeight = 100 + Math.random() * 200; // 100-300px
				
				img.style.left = x + 'px';
				img.style.top = y + 'px';
				img.style.width = '0px';
				img.style.height = '0px';
				img.style.transform = 'translate(-50%, -50%)';
				
				img.onload = function() {
					console.log('Cloud image loaded successfully:', img.src);
				};
				
				img.onerror = function() {
					console.error('Failed to load cloud image:', img.src);
				};
				
				document.body.appendChild(img);
				console.log('Cloud image added to DOM at position:', x, y);
				
				const cloudData = {
					element: img,
					x: x,
					y: y,
					currentWidth: 0,
					currentHeight: 0,
					finalWidth: finalWidth,
					finalHeight: finalHeight,
					phase: 'scaling', // 'scaling', 'waiting', 'scanning', 'complete'
					startTime: performance.now(),
					scaleDuration: 200 + Math.random() * 300, // 0.2-0.5 seconds to scale (much faster!)
					scanner: null
				};
				
				return cloudData;
			}

			function createWanderingScanner() {
				const scanner = document.createElement('div');
				scanner.className = 'hud-scanner';
				
				// Add frame elements for cooler look
				const frame = document.createElement('div');
				frame.className = 'hud-scanner-frame';
				scanner.appendChild(frame);
				
				const corners = document.createElement('div');
				corners.className = 'hud-scanner-corners';
				scanner.appendChild(corners);
				
				const line = document.createElement('div');
				line.className = 'hud-scanner-line';
				scanner.appendChild(line);
				
				// Random starting position
				const startX = Math.random() * window.innerWidth;
				const startY = Math.random() * window.innerHeight;
				
				scanner.style.left = startX + 'px';
				scanner.style.top = startY + 'px';
				scanner.style.transform = 'translate(-50%, -50%)';
				scanner.style.width = '20px';
				scanner.style.height = '20px';
				scanner.setAttribute('data-status', 'Scanning');
				
				document.body.appendChild(scanner);
				
				// Random wandering direction and speed
				const angle = Math.random() * Math.PI * 2;
				const speed = 1 + Math.random() * 1.5; // 1-2.5 pixels per frame (normal patrol speed)
				
				const scannerData = {
					element: scanner,
					currentX: startX,
					currentY: startY,
					velocityX: Math.cos(angle) * speed,
					velocityY: Math.sin(angle) * speed,
					phase: 'wandering', // 'wandering', 'targeting', 'scanning', 'returning'
					lastDirectionChange: performance.now(),
					targetCloud: null,
					initialWidth: 20,
					initialHeight: 20
				};
				
				console.log('Created wandering scanner at', startX, startY);
				return scannerData;
			}

			function initializeWanderingScanners() {
				// Create initial set of wandering scanners
				for (let i = 0; i < maxScanners; i++) {
					wanderingScanners.push(createWanderingScanner());
				}
			}

			function updateCloudImages(currentTime) {
				// Update debug status
				if (window.cloudDebug) {
					const timeSinceSpawn = Math.round((currentTime - lastCloudSpawnTime) / 100) / 10;
					window.cloudDebug.status = `Next: ${Math.max(0, Math.round((cloudSpawnInterval - (currentTime - lastCloudSpawnTime)) / 100) / 10)}s, Active: ${cloudImages.length}, Enabled: ${window.cloudControls && window.cloudControls.enabled ? 'YES' : 'NO'}`;
				}
				
				// Debug logging
				if (currentTime % 1000 < 16) { // Log roughly every second
					console.log('Cloud spawn check:', {
						cloudControlsEnabled: window.cloudControls && window.cloudControls.enabled,
						showHomepageUI: showHomepageUI,
						introPhase: introPhase,
						timeSinceLastSpawn: currentTime - lastCloudSpawnTime,
						spawnInterval: cloudSpawnInterval
					});
				}
				
				// Spawn new cloud images (works on homepage too!)
				if (window.cloudControls && window.cloudControls.enabled && 
					currentTime - lastCloudSpawnTime > cloudSpawnInterval) {
					console.log('Auto-spawning new cloud image...');
					cloudImages.push(createCloudImage());
					lastCloudSpawnTime = currentTime;
				}
				
				// Update existing cloud images
				cloudImages = cloudImages.filter(cloud => {
					const elapsed = currentTime - cloud.startTime;
					
					if (cloud.phase === 'scaling') {
						// Scale up linearly
						const progress = Math.min(elapsed / cloud.scaleDuration, 1);
						cloud.currentWidth = cloud.finalWidth * progress;
						cloud.currentHeight = cloud.finalHeight * progress;
						
						cloud.element.style.width = cloud.currentWidth + 'px';
						cloud.element.style.height = cloud.currentHeight + 'px';
						
						if (progress >= 1) {
							cloud.phase = 'ready'; // Ready to be detected by wandering scanners
							// Immediately assign to nearest available scanner
							assignScannerToCloud(cloud);
						}
					} else if (cloud.phase === 'ready') {
						// Cloud is ready to be detected by wandering scanners
						// (No action needed here, wandering scanners will find it)
					} else if (cloud.phase === 'being_scanned') {
						// Cloud is being scanned, wait for completion
						// (Scanner handles its own lifecycle)
					}
					
					// Remove completed clouds
					return cloud.phase !== 'complete';
				});
			}

			function updateWanderingScanners(currentTime) {
				// Ensure we have the right number of scanners
				while (wanderingScanners.length < maxScanners) {
					wanderingScanners.push(createWanderingScanner());
				}
				
				wanderingScanners.forEach(scanner => {
					if (!scanner.element || !scanner.element.parentNode) return;
					
					if (scanner.phase === 'wandering') {
						// Random wandering behavior
						scanner.currentX += scanner.velocityX;
						scanner.currentY += scanner.velocityY;
						
						// Bounce off screen edges
						if (scanner.currentX < 0 || scanner.currentX > window.innerWidth) {
							scanner.velocityX *= -1;
							scanner.currentX = Math.max(0, Math.min(window.innerWidth, scanner.currentX));
						}
						if (scanner.currentY < 0 || scanner.currentY > window.innerHeight) {
							scanner.velocityY *= -1;
							scanner.currentY = Math.max(0, Math.min(window.innerHeight, scanner.currentY));
						}
						
						// Randomly change direction occasionally
						if (currentTime - scanner.lastDirectionChange > 2000 + Math.random() * 3000) {
							const angle = Math.random() * Math.PI * 2;
							const speed = 1 + Math.random() * 1.5; // Normal patrol speed
							scanner.velocityX = Math.cos(angle) * speed;
							scanner.velocityY = Math.sin(angle) * speed;
							scanner.lastDirectionChange = currentTime;
						}
						
						// Scanners are now assigned directly when clouds appear
						// No need for automatic detection
						
					} else if (scanner.phase === 'targeting') {
						// Move toward detected cloud
						const cloud = scanner.targetCloud;
						if (!cloud || cloud.phase === 'complete') {
							// Target lost, return to wandering
							scanner.phase = 'wandering';
							scanner.targetCloud = null;
							return;
						}
						
						const dx = cloud.x - scanner.currentX;
						const dy = cloud.y - scanner.currentY;
						const distance = Math.sqrt(dx * dx + dy * dy);
						
						if (distance > 5) {
							const moveSpeed = 10; // Much faster targeting speed
							scanner.currentX += (dx / distance) * moveSpeed;
							scanner.currentY += (dy / distance) * moveSpeed;
						} else {
							// Reached target, start scanning
							scanner.phase = 'scanning';
							scanner.scanStartTime = currentTime;
							scanner.growthStartTime = currentTime;
							scanner.targetWidth = cloud.finalWidth;
							scanner.targetHeight = cloud.finalHeight;
							scanner.element.classList.add('scanning');
							scanner.element.setAttribute('data-status', 'Identified');
							console.log(`Scanner analyzing cloud: ${scanner.targetWidth}x${scanner.targetHeight}`);
						}
						
					} else if (scanner.phase === 'scanning') {
						const elapsed = currentTime - scanner.scanStartTime;
						const growthElapsed = currentTime - scanner.growthStartTime;
						
						// Grow to match image size
						if (growthElapsed < 300) {
							const growthProgress = growthElapsed / 300;
							const easeProgress = 1 - Math.pow(1 - growthProgress, 3);
							
							const currentWidth = scanner.initialWidth + (scanner.targetWidth - scanner.initialWidth) * easeProgress;
							const currentHeight = scanner.initialHeight + (scanner.targetHeight - scanner.initialHeight) * easeProgress;
							
							scanner.element.style.width = currentWidth + 'px';
							scanner.element.style.height = currentHeight + 'px';
						}
						
						// Complete scan
						if (elapsed > 800) {
							// Remove cloud and reset scanner
							scanner.targetCloud.element.remove();
							scanner.targetCloud.phase = 'complete';
							
							// Reset scanner to wandering
							scanner.phase = 'returning';
							scanner.returnStartTime = currentTime;
							scanner.element.classList.remove('scanning');
							console.log('Scanner completed analysis, returning to patrol');
						}
						
					} else if (scanner.phase === 'returning') {
						// Shrink back to original size and resume wandering
						const elapsed = currentTime - scanner.returnStartTime;
						if (elapsed < 200) {
							const shrinkProgress = elapsed / 200;
							const currentWidth = scanner.targetWidth - (scanner.targetWidth - scanner.initialWidth) * shrinkProgress;
							const currentHeight = scanner.targetHeight - (scanner.targetHeight - scanner.initialHeight) * shrinkProgress;
							
							scanner.element.style.width = currentWidth + 'px';
							scanner.element.style.height = currentHeight + 'px';
						} else {
							// Return to wandering
							scanner.element.style.width = scanner.initialWidth + 'px';
							scanner.element.style.height = scanner.initialHeight + 'px';
							scanner.element.setAttribute('data-status', 'Scanning');
							scanner.phase = 'wandering';
							scanner.targetCloud = null;
							
							// New random direction
							const angle = Math.random() * Math.PI * 2;
							const speed = 1 + Math.random() * 1.5; // Normal patrol speed
							scanner.velocityX = Math.cos(angle) * speed;
							scanner.velocityY = Math.sin(angle) * speed;
						}
					}
					
					// Update visual position
					scanner.element.style.left = scanner.currentX + 'px';
					scanner.element.style.top = scanner.currentY + 'px';
				});
			}


			function assignScannerToCloud(cloud) {
				// Find the nearest available (wandering) scanner
				let nearestScanner = null;
				let nearestDistance = Infinity;
				
				wanderingScanners.forEach(scanner => {
					if (scanner.phase === 'wandering') {
						const dx = cloud.x - scanner.currentX;
						const dy = cloud.y - scanner.currentY;
						const distance = Math.sqrt(dx * dx + dy * dy);
						
						if (distance < nearestDistance) {
							nearestDistance = distance;
							nearestScanner = scanner;
						}
					}
				});
				
				if (nearestScanner) {
					// Assign this scanner to the cloud
					nearestScanner.phase = 'targeting';
					nearestScanner.targetCloud = cloud;
					cloud.phase = 'being_scanned';
					console.log('Assigned scanner to new cloud image');
				} else {
					console.log('No available scanners for new cloud');
				}
			}

			function drawChatboxes() {
				if (!overlayCtx) return;
				
				// Clear canvas
				overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
				
				const currentTime = performance.now();
				
				// Update cloud images
				updateCloudImages(currentTime);
				
				// Update wandering scanners
				updateWanderingScanners(currentTime);
				
				// Initialize intro timing
				if (introStartTime === 0) {
					introStartTime = currentTime;
				}
				
				// Determine current intro phase
				const timeSinceStart = currentTime - introStartTime;
				if (timeSinceStart < introDuration) {
					introPhase = 'flood';
				} else if (timeSinceStart < introDuration + stragglerDuration) {
					introPhase = 'stragglers';
				} else if (timeSinceStart < introDuration + stragglerDuration + transitionDuration) {
					introPhase = 'transition';
				} else {
					introPhase = 'normal';
				}
				
				const speed = window.chatboxControls ? window.chatboxControls.speed : 1.0;
				const connectionDistance = window.chatboxControls ? window.chatboxControls.connectionDistance * 12 : 40; // Scaled for low-res
				
				// Handle spawning based on intro phase
				if (introPhase === 'flood') {
					// Flood phase: massive wave of varied speed chatboxes
					if (currentTime - lastSpawnTime > 50) { // Every 50ms - very frequent
						// Spawn many chatboxes with varied speeds to completely cover screen
						for (let i = 0; i < 8; i++) { // 8 chatboxes every 50ms = 160 per second!
							let speedTier;
							const rand = Math.random();
							if (rand < 0.4) speedTier = 'superfast';      // 40% superfast
							else if (rand < 0.7) speedTier = 'fast';      // 30% fast  
							else speedTier = 'medium';                     // 30% medium
							
							chatboxes2D.push(createNewChatbox(null, speedTier));
						}
						lastSpawnTime = currentTime;
					}
				} else if (introPhase === 'stragglers') {
					// Straggler phase: fewer, slower chatboxes trickling through
					if (currentTime - lastSpawnTime > 200) { // Every 200ms
						// Spawn fewer stragglers with slower speeds
						for (let i = 0; i < 2; i++) {
							let speedTier;
							const rand = Math.random();
							if (rand < 0.3) speedTier = 'medium';         // 30% medium
							else if (rand < 0.7) speedTier = 'slow';      // 40% slow
							else speedTier = 'normal';                    // 30% normal
							
							chatboxes2D.push(createNewChatbox(null, speedTier));
						}
						lastSpawnTime = currentTime;
					}
				} else if (introPhase === 'transition') {
					// Transition phase: gradually slow down to normal spawning
					const transitionProgress = (timeSinceStart - introDuration - stragglerDuration) / transitionDuration;
					const currentSpawnRate = 200 + (spawnInterval - 200) * transitionProgress; // Lerp from 200ms to normal
					if (currentTime - lastSpawnTime > currentSpawnRate) {
						chatboxes2D.push(createNewChatbox(null, 'normal'));
						lastSpawnTime = currentTime;
					}
				} else {
					// Normal phase: regular spawning
					if (currentTime - lastSpawnTime > spawnInterval) {
						chatboxes2D.push(createNewChatbox(null, 'normal'));
						lastSpawnTime = currentTime;
					}
				}
				
				// Update positions and remove chatboxes that have left the screen
				chatboxes2D = chatboxes2D.filter(chatbox => {
					// Update position
					chatbox.x += chatbox.vx * speed;
					chatbox.y += chatbox.vy * speed;
					
					// Randomly update text styling every 2-4 seconds
					if (currentTime - chatbox.styleUpdateTime > 2000 + Math.random() * 2000) {
						chatbox.textStyles = generateRandomTextStyles();
						chatbox.styleUpdateTime = currentTime;
					}
					
					// Keep vertical position within bounds with soft bouncing (no margins)
					const caretMargin = 20 / pixelScale; // Small margin only for caret extending below
					if (chatbox.y < 0) {
						chatbox.y = 0;
						chatbox.vy = Math.abs(chatbox.vy) * 0.5; // Soft bounce down
					}
					if (chatbox.y > overlayCanvas.height - chatbox.height - caretMargin) {
						chatbox.y = overlayCanvas.height - chatbox.height - caretMargin;
						chatbox.vy = -Math.abs(chatbox.vy) * 0.5; // Soft bounce up
					}
					
					// Remove chatboxes that have moved off the left side
					return chatbox.x > -chatbox.width - 20;
				});
				
				// Draw connection lines
				overlayCtx.strokeStyle = 'black'; // Solid black
				overlayCtx.lineWidth = Math.max(1, Math.round(2 / pixelScale)); // Thin lines, scaled with pixelation
				
				for (let i = 0; i < chatboxes2D.length; i++) {
					for (let j = i + 1; j < chatboxes2D.length; j++) {
						const dx = (chatboxes2D[i].x + chatboxes2D[i].width/2) - (chatboxes2D[j].x + chatboxes2D[j].width/2);
						const dy = (chatboxes2D[i].y + chatboxes2D[i].height/2) - (chatboxes2D[j].y + chatboxes2D[j].height/2);
						const distance = Math.sqrt(dx * dx + dy * dy);
						
						if (distance < connectionDistance) {
							overlayCtx.beginPath();
							overlayCtx.moveTo(chatboxes2D[i].x + chatboxes2D[i].width/2, chatboxes2D[i].y + chatboxes2D[i].height/2);
							overlayCtx.lineTo(chatboxes2D[j].x + chatboxes2D[j].width/2, chatboxes2D[j].y + chatboxes2D[j].height/2);
							overlayCtx.stroke();
						}
					}
				}
				
				// Draw speech bubbles
				chatboxes2D.forEach(chatbox => {
					drawSpeechBubble(chatbox);
				});
			}

			function drawSpeechBubble(chatbox) {
				// Scale elements based on pixelation level to maintain consistent appearance
				const baseCaretSize = 20; // Base caret size for screen
				const baseCaretOffset = 32; // Base caret position offset
				
				const caretSize = baseCaretSize / pixelScale;
				const caretX = chatbox.x + (baseCaretOffset / pixelScale);
				const caretY = chatbox.y + chatbox.height;

				const isFF7Style = window.chatboxControls && window.chatboxControls.style === 'ff7';

				if (isFF7Style) {
					// FF7 Style: Deep blue gradient background
					const gradient = overlayCtx.createLinearGradient(
						chatbox.x, chatbox.y, 
						chatbox.x, chatbox.y + chatbox.height
					);
					gradient.addColorStop(0, '#1e3a5f'); // Lighter blue at top
					gradient.addColorStop(0.5, '#0f1f3d'); // Medium blue in middle  
					gradient.addColorStop(1, '#061426'); // Dark blue at bottom
					
					overlayCtx.fillStyle = gradient;
					overlayCtx.strokeStyle = '#4a6fa5'; // Light blue border
					overlayCtx.lineWidth = Math.max(1, Math.round(2 / pixelScale));
				} else {
					// Classic Style: White background with black border
					overlayCtx.fillStyle = 'white';
					overlayCtx.strokeStyle = 'black';
					overlayCtx.lineWidth = Math.max(1, Math.round(4 / pixelScale));
				}

				// First, fill both the box and caret as one shape
				overlayCtx.beginPath();
				// Main rectangle
				overlayCtx.rect(chatbox.x, chatbox.y, chatbox.width, chatbox.height);
				// Add caret triangle
				overlayCtx.moveTo(caretX - caretSize, caretY);
				overlayCtx.lineTo(caretX + caretSize, caretY);
				overlayCtx.lineTo(caretX, caretY + caretSize);
				overlayCtx.closePath();
				overlayCtx.fill();

				// Now stroke the box but skip the bottom section where caret connects
				overlayCtx.beginPath();
				// Top edge
				overlayCtx.moveTo(chatbox.x, chatbox.y);
				overlayCtx.lineTo(chatbox.x + chatbox.width, chatbox.y);
				// Right edge
				overlayCtx.lineTo(chatbox.x + chatbox.width, chatbox.y + chatbox.height);
				// Bottom edge - but skip the caret area
				overlayCtx.lineTo(caretX + caretSize, caretY);
				overlayCtx.moveTo(caretX - caretSize, caretY);
				overlayCtx.lineTo(chatbox.x, caretY);
				// Left edge
				overlayCtx.lineTo(chatbox.x, chatbox.y);
				overlayCtx.stroke();

				// Stroke only the outer edges of the caret
				overlayCtx.beginPath();
				overlayCtx.moveTo(caretX - caretSize, caretY);
				overlayCtx.lineTo(caretX, caretY + caretSize);
				overlayCtx.lineTo(caretX + caretSize, caretY);
				overlayCtx.stroke();
				
				// Draw text with random styling
				overlayCtx.fillStyle = isFF7Style ? 'white' : 'black';
				overlayCtx.textBaseline = 'middle';
				
				// Make font size relative to chatbox height (about 40% of height)
				const textBaseFontSize = chatbox.height * 0.4;
				const fontFamily = customFontLoaded ? 'Epmarugo' : 'monospace';
				
				// Calculate total text width to center it
				let totalWidth = 0;
				chatbox.textStyles.forEach(fragment => {
					const fontSize = textBaseFontSize * fragment.sizeMultiplier;
					const weight = fragment.bold ? 'bold' : 'normal';
					overlayCtx.font = `${weight} ${fontSize}px ${fontFamily}`;
					totalWidth += overlayCtx.measureText(fragment.text).width;
				});
				
				// Scale down text if it's too wide for the chatbox (leave some padding)
				const maxWidth = chatbox.width * 0.9; // 90% of chatbox width
				const textScale = totalWidth > maxWidth ? maxWidth / totalWidth : 1;
				
				// Start position for centered text
				let currentX = chatbox.x + (chatbox.width - (totalWidth * textScale)) / 2;
				const textY = chatbox.y + chatbox.height / 2;
				
				// Draw each fragment with its own styling
				chatbox.textStyles.forEach(fragment => {
					const fontSize = (textBaseFontSize * fragment.sizeMultiplier) * textScale;
					const weight = fragment.bold ? 'bold' : 'normal';
					overlayCtx.font = `${weight} ${fontSize}px ${fontFamily}`;
					
					overlayCtx.fillText(fragment.text, currentX, textY);
					currentX += overlayCtx.measureText(fragment.text).width;
				});
			}

			init();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				const width = document.documentElement.clientWidth;
				const height = document.documentElement.clientHeight;

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xffffff, 1 ); // Set background to white
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );
				// Always stretch canvas to full window; we'll animate internal resolution separately
				renderer.domElement.style.width = width + 'px';
				renderer.domElement.style.height = height + 'px';

				camera = new THREE.PerspectiveCamera( 65, width / height, 3, 10 );
				camera.position.z = 7;

				scene = new THREE.Scene();

				group = new THREE.Object3D();
				scene.add( group );

				const light = new THREE.PointLight( 0xefffef, 500 );
				light.position.z = 10;
				light.position.y = - 10;
				light.position.x = - 10;
				scene.add( light );

				const light2 = new THREE.PointLight( 0xffefef, 500 );
				light2.position.z = 10;
				light2.position.x = - 10;
				light2.position.y = 10;
				scene.add( light2 );

				const light3 = new THREE.PointLight( 0xefefff, 500 );
				light3.position.z = 10;
				light3.position.x = 10;
				light3.position.y = - 10;
				scene.add( light3 );

				const light4 = new THREE.AmbientLight( 0xffffff, 0.2 );
				scene.add( light4 );

				// Color scheme system
				initializeColorSchemes();

				const geometry = new THREE.SphereGeometry( 3, 48, 24 );

				for ( let i = 0; i < 120; i ++ ) {

					const material = new THREE.MeshStandardMaterial();
					material.roughness = 0.5 * Math.random() + 0.25;
					material.metalness = 0;
					const c = generateColor();
					material.color.setHSL( c.h, c.s, c.l );

					const mesh = new THREE.Mesh( geometry, material );
					mesh.position.x = Math.random() * 4 - 2;
					mesh.position.y = Math.random() * 4 - 2;
					mesh.position.z = Math.random() * 4 - 2;
					mesh.rotation.x = Math.random();
					mesh.rotation.y = Math.random();
					mesh.rotation.z = Math.random();

					mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 0.2 + 0.05;
					group.add( mesh );

				}

				// Keyboard controls for quick scheme tweaking
				setupColorControlsUI();

				// Create 2D overlay canvas for chatboxes
				createOverlayCanvas();
				
				// Initialize wandering scanners
				initializeWanderingScanners();
				
				// Spawn initial cloud image immediately
				setTimeout(() => {
					if (cloudImages.length === 0) {
						cloudImages.push(createCloudImage());
						console.log('Spawned initial cloud image');
					}
				}, 100); // Small delay to ensure everything is initialized

				// stats = new Stats();
				// container.appendChild( stats.dom );

				composer = new EffectComposer( renderer );
				renderPass = new RenderPass( scene, camera );
				composer.addPass( renderPass );
				saoPass = new SAOPass( scene, camera );
				
				// Set default SAOPass parameters
				saoPass.params.output = SAOPass.OUTPUT.Default;
				saoPass.params.saoBias = 0.5;
				saoPass.params.saoIntensity = 0.42;
				saoPass.params.saoScale = 6;
				saoPass.params.saoKernelRadius = 100;
				saoPass.params.saoMinResolution = 0;
				saoPass.params.saoBlur = false;
				saoPass.params.saoBlurRadius = 8;
				saoPass.params.saoBlurStdDev = 4;
				saoPass.params.saoBlurDepthCutoff = 0.01;
				
				composer.addPass( saoPass );
				
				// Add dithering pass
				ditheringPass = new ShaderPass( DitheringShader );
				ditheringPass.uniforms.resolution.value.set( window.innerWidth, window.innerHeight );
				ditheringPass.enabled = false; // Start with dithering disabled
				composer.addPass( ditheringPass );
				
				const outputPass = new OutputPass();
				composer.addPass( outputPass );

				// Build 3D title scene inside the card
				initializeThreeTitle();

				// Initialize default control values
				window.chatboxControls = {
					visible: true,
					speed: 2.0,
					connectionDistance: 12.0,
					spawnRate: 2.0,
					pixelation: 2,
					style: 'classic' // 'classic' or 'ff7'
				};

				window.cloudControls = {
					enabled: true,
					spawnRate: 0.5, // clouds per second
					scannerCount: 4
				};
				
				window.cloudDebug = {
					status: 'Waiting...'
				};

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				const width = document.documentElement.clientWidth || 1;
				const height = document.documentElement.clientHeight || 1;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();
				renderer.setSize( width, height );

				composer.setSize( width, height );
				
				// Update dithering pass resolution
				ditheringPass.uniforms.resolution.value.set( width, height );
				
				// Resize overlay canvas
				if ( overlayCanvas ) {
					resizeOverlayCanvas();
				}
				

			}

			// Color schemes and controls
			function initializeColorSchemes() {
				colorSchemes = {
					dorficOrangeWhite: () => {
						// 50/50 mix of vibrant orange spheres and near-white spheres
						if (Math.random() < 0.5) {
							// Orange around 30-45 degrees (0.08-0.12 in H on [0,1])
							const hue = 0.08 + (Math.random() - 0.5) * 0.02; // tight hue jitter
							const s = clamp01((colorControls.s || 0.55) + (Math.random() - 0.5) * 0.08);
							const l = clamp01((colorControls.l || 0.50) + (Math.random() - 0.5) * 0.06);
							return { h: hue, s, l };
						} else {
							// Nearly white: zero saturation, high lightness
							const l = clamp01(0.90 + (Math.random() - 0.5) * 0.06);
							return { h: 0, s: 0.0, l };
						}
					},
					dualTealPurple: () => {
						const base = Math.random() < 0.5 ? 0.58 : 0.78;
						return { h: clamp01(base + (Math.random() - 0.5) * getJitterH()), s: getS(), l: getL(0.03) };
					},
					dualBlueOrange: () => {
						const base = Math.random() < 0.5 ? 0.60 : 0.08;
						return { h: clamp01(base + (Math.random() - 0.5) * getJitterH()), s: getS(), l: getL(0.02) };
					},
					dualForestRose: () => {
						const base = Math.random() < 0.5 ? 0.33 : 0.95;
						return { h: clamp01(base + (Math.random() - 0.5) * getJitterH()), s: getS(0.4, 0.15), l: getL(0.04) };
					},
					multicolorMuted: () => {
						return { h: Math.random(), s: getS(0.45, 0.15), l: getL(0.05, 0.33) };
					},
					warmMuted: () => {
						const warm = 0.02 + Math.random() * 0.18;
						return { h: warm, s: getS(0.45, 0.12), l: getL(0.05, 0.36) };
					},
					coolMuted: () => {
						const cool = 0.55 + Math.random() * 0.25;
						return { h: cool, s: getS(0.45, 0.12), l: getL(0.05, 0.36) };
					},
					grayscale: () => {
						const l = clamp01((getBaseL() - 0.02) + (Math.random() - 0.5) * 0.08);
						return { h: 0, s: 0, l };
					}
				};
				colorSchemeNames = Object.keys(colorSchemes);
				const params = new URLSearchParams(window.location.search);
				const initialScheme = params.get('scheme') && colorSchemes[params.get('scheme')] ? params.get('scheme') : 'dualTealPurple';
				colorControls = {
					schemeIndex: colorSchemeNames.indexOf(initialScheme),
					s: clamp01(parseFloat(params.get('s')) || 0.5),
					l: clamp01(parseFloat(params.get('l')) || 0.4),
					jitterH: clamp01(parseFloat(params.get('j')) || 0.06)
				};
			}

			function getSchemeName() {
				return colorSchemeNames[(colorControls.schemeIndex + colorSchemeNames.length) % colorSchemeNames.length];
			}

			function getS(base = 0.5, range = 0.1) {
				const sBase = colorControls.s || base;
				return clamp01(sBase + (Math.random() - 0.5) * range);
			}

			function getBaseL(defaultL = 0.4) {
				return colorControls.l || defaultL;
			}

			function getL(range = 0.06, defaultL = 0.4) {
				const lBase = getBaseL(defaultL);
				return clamp01(lBase + (Math.random() - 0.5) * range);
			}

			function getJitterH() { return colorControls.jitterH; }
			function clamp01(x) { return Math.max(0, Math.min(1, x)); }

			function generateColor() {
				const scheme = colorSchemes[getSchemeName()];
				return scheme();
			}

			function applyColorsToGroup() {
				if (!group) return;
				group.children.forEach(obj => {
					if (obj.material && obj.material.color) {
						const c = generateColor();
						obj.material.color.setHSL(c.h, c.s, c.l);
					}
				});
				updateURLParams();
				console.log('Applied scheme:', getSchemeName(), 's=', colorControls.s.toFixed(2), 'l=', colorControls.l.toFixed(2));
			}

			function updateURLParams() {
				const params = new URLSearchParams(window.location.search);
				params.set('scheme', getSchemeName());
				params.set('s', String(colorControls.s.toFixed(2)));
				params.set('l', String(colorControls.l.toFixed(2)));
				params.set('j', String(colorControls.jitterH.toFixed(2)));
				history.replaceState(null, '', `${location.pathname}?${params.toString()}`);
			}

			function setupColorControlsUI() {
				window.addEventListener('keydown', (e) => {
					if (e.key === ']') { colorControls.schemeIndex = (colorControls.schemeIndex + 1) % colorSchemeNames.length; applyColorsToGroup(); }
					if (e.key === '[') { colorControls.schemeIndex = (colorControls.schemeIndex - 1 + colorSchemeNames.length) % colorSchemeNames.length; applyColorsToGroup(); }
					if (e.key === 'S') { colorControls.s = clamp01(colorControls.s + 0.05); applyColorsToGroup(); }
					if (e.key === 's') { colorControls.s = clamp01(colorControls.s - 0.05); applyColorsToGroup(); }
					if (e.key === 'L') { colorControls.l = clamp01(colorControls.l + 0.05); applyColorsToGroup(); }
					if (e.key === 'l') { colorControls.l = clamp01(colorControls.l - 0.05); applyColorsToGroup(); }
					if (e.key === 'J') { colorControls.jitterH = clamp01(colorControls.jitterH + 0.02); applyColorsToGroup(); }
					if (e.key === 'j') { colorControls.jitterH = clamp01(colorControls.jitterH - 0.02); applyColorsToGroup(); }
					if (e.key === 'r') { applyColorsToGroup(); }
					if (e.key >= '1' && e.key <= '9') {
						const idx = parseInt(e.key, 10) - 1;
						if (idx < colorSchemeNames.length) { colorControls.schemeIndex = idx; applyColorsToGroup(); }
					}
					if (e.key === '0') {
						const dorficIdx = colorSchemeNames.indexOf('dorficOrangeWhite');
						if (dorficIdx !== -1) { colorControls.schemeIndex = dorficIdx; applyColorsToGroup(); }
					}
				});
				// Apply initial colors from URL params
				applyColorsToGroup();
			}

			function animate() {

				// stats.begin();
				render();
				// stats.end();

			}

			function render() {

				const timer = performance.now();
				group.rotation.x = timer * 0.0002;
				group.rotation.y = timer * 0.0001;

				// Animate background internal resolution to create pixelation without shader
				if ( pixelationAnim.enabled ) {
					const displayW = document.documentElement.clientWidth || window.innerWidth || 1;
					const displayH = document.documentElement.clientHeight || window.innerHeight || 1;
					const t = (Math.sin(timer * 0.001 * (Math.PI * 2) * pixelationAnim.speedHz) + 1) * 0.5; // 0..1
					const scale = pixelationAnim.minScale + (pixelationAnim.maxScale - pixelationAnim.minScale) * t;
					const internalW = Math.max(1, Math.floor(displayW * scale));
					const internalH = Math.max(1, Math.floor(displayH * scale));
					if (internalW !== pixelationAnim.lastW || internalH !== pixelationAnim.lastH) {
						// Resize internal render buffers, keep CSS stretched to full window
						renderer.setSize(internalW, internalH, false);
						composer.setSize(internalW, internalH);
						renderer.domElement.style.width = displayW + 'px';
						renderer.domElement.style.height = displayH + 'px';
						pixelationAnim.lastW = internalW;
						pixelationAnim.lastH = internalH;
					}
				}

				// Draw 2D chatboxes overlay
				if ( window.chatboxControls && window.chatboxControls.visible ) {
					drawChatboxes();
				}

				composer.render();

				// Render title scene if available
				if (titleRenderer && titleScene && titleCamera && titleMesh) {
					const time = performance.now() * 0.001;
					
					// Animate EX and Research separately
					if (exMesh) {
						exMesh.rotation.y = Math.sin(time) * 0.2;
						exMesh.position.y = Math.sin(time * 0.7) * 0.1;
					}
					if (researchMesh) {
						researchMesh.rotation.y = Math.sin(time + 1.5) * 0.15;
						researchMesh.position.y = Math.sin(time * 0.5 + 2) * 0.08;
					}
					
					titleRenderer.render(titleScene, titleCamera);
				}

			}

			function initializeThreeTitle() {
				titleMount = document.getElementById('three-title');
				if (!titleMount) return;
				// Use client size to avoid transform(scale(0)) shrinking bounding box
				let w = Math.max(1, titleMount.clientWidth || (titleMount.parentElement ? titleMount.parentElement.clientWidth : 0) || window.innerWidth);
				let h = Math.max(1, titleMount.clientHeight || 220);
				titleRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
				titleRenderer.setPixelRatio(window.devicePixelRatio);
				titleRenderer.setSize(w, h, false);
				titleRenderer.setClearColor(0x000000, 0);
				titleMount.innerHTML = '';
				titleMount.appendChild(titleRenderer.domElement);

				titleScene = new THREE.Scene();
				titleCamera = new THREE.PerspectiveCamera(45, w / h, 0.1, 100);
					titleCamera.position.set(0, 0, 16);

				// Lighting - much brighter to simulate 1.5x brightness
				const key = new THREE.DirectionalLight(0xffffff, 2.0); // doubled intensity
				key.position.set(2, 3, 5);
				titleScene.add(key);
				const fill = new THREE.DirectionalLight(0xa0b9ff, 1.2); // doubled intensity
				fill.position.set(-3, 2, 2);
				titleScene.add(fill);
				const rim = new THREE.DirectionalLight(0xfff0d0, 1.0); // doubled intensity
				rim.position.set(0, -2, -4);
				titleScene.add(rim);
				// Add ambient light for overall brightness boost
				const ambient = new THREE.AmbientLight(0xffffff, 0.4);
				titleScene.add(ambient);

				// 3D text using bevelled ExtrudeGeometry
				const textLoader = new FontLoader();
				textLoader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function(font) {
					const textGeo = new TextGeometry('EX Research', {
						font: font,
						size: 3.0,
						height: 0.7,
						curveSegments: 8,
						bevelEnabled: true,
						bevelThickness: 0.25,
						bevelSize: 0.15,
						bevelSegments: 3
					});
					textGeo.computeBoundingBox();
					textGeo.center();

					// Helper to create a mesh with one material applied to whole geometry
					function createTextMesh(str, material) {
						const geo = new TextGeometry(str, {
							font: font,
							size: 3.0,
							height: 0.7,
							curveSegments: 8,
							bevelEnabled: true,
							bevelThickness: 0.25,
							bevelSize: 0.15,
							bevelSegments: 3
						});
						geo.computeBoundingBox();
						const mesh = new THREE.Mesh(geo, material);
						return { mesh, geo };
					}

					// Materials: EX and Research - colors that complement the soft pastel palette
					const exMaterial = new THREE.MeshPhysicalMaterial({
						color: 0xffd700, // warm golden yellow - complements the pastels
						metalness: 0.1,
						roughness: 0.3,
						reflectivity: 0.8,
						clearcoat: 0.8,
						clearcoatRoughness: 0.1,
						emissive: 0x886600 // golden glow
					});
					const researchMaterial = new THREE.MeshPhongMaterial({
						color: 0xff69b4, // soft hot pink - matches the pastel aesthetic
						shininess: 80,
						specular: 0xffffff,
						emissive: 0x883355 // pink glow
					});

					const { mesh: exMeshLocal, geo: exGeo } = createTextMesh('EX', exMaterial);
					const { mesh: researchMeshLocal, geo: researchGeo } = createTextMesh('Research', researchMaterial);

					// Compute widths to center combined group
					const exBB = exGeo.boundingBox; const exW = exBB.max.x - exBB.min.x;
					const resBB = researchGeo.boundingBox; const resW = resBB.max.x - resBB.min.x;
					const spacing = 1; // slight negative kerning to pull words together
					const totalW = exW + resW + spacing;
					exMeshLocal.position.x = -totalW / 2;
					researchMeshLocal.position.x = exMeshLocal.position.x + exW + spacing;

					// Store individual meshes for separate animation
					exMesh = exMeshLocal;
					researchMesh = researchMeshLocal;
					
					// Create group so we can rotate one handle
					const grp = new THREE.Group();
					grp.add(exMeshLocal);
					grp.add(researchMeshLocal);
					titleScene.add(grp);
					titleMesh = grp;
				});

				// Handle resize
				function resizeTitle() {
					if (!titleMount || !titleRenderer) return;
					const cw = Math.max(1, titleMount.clientWidth || (titleMount.parentElement ? titleMount.parentElement.clientWidth : 0) || window.innerWidth);
					const ch = Math.max(1, titleMount.clientHeight || 170);
					titleRenderer.setSize(cw, ch, false);
					titleCamera.aspect = cw / ch;
					titleCamera.updateProjectionMatrix();
				}
				window.addEventListener('resize', resizeTitle);
				// After entrance animation, re-measure once to capture final size
				setTimeout(resizeTitle, 450);
			}

		</script>
	</body>
</html>