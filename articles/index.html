<!DOCTYPE html>
<html lang="en">
	<head>
		<title>EX Research - Home</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<link rel="stylesheet" href="https://unpkg.com/7.css">
		<style>

			@font-face {
				font-family: 'ff7';
				src: url('assets/Final_Fantasy_VII.ttf') format('truetype');
			}

			html, body {
				margin: 0;
				padding: 0;
				/* overflow: hidden; */
				width: 100%;
				height: 100%;
			}

			.agency-card {
				box-sizing: border-box;
				border-radius: 2px;
			}

			canvas {
				pointer-events: none;
				overflow: hidden;
			}
			
			#homepage-ui {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				display: flex;
				flex-direction: column;
				justify-content: flex-start;
				align-items: center;
				z-index: 200;
				pointer-events: auto;
				font-family: 'Arial Narrow', monospace;
				padding: 40px 20px;
				padding-bottom: 0;
				overflow: auto;
				box-sizing: border-box;
			}

			.header {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				background: rgba(255, 255, 255, 0.95);
				backdrop-filter: blur(10px);
				border-bottom: 1px solid #000;
				z-index: 300;
				pointer-events: auto;
				padding: 15px 0;
			}

			.header-content {
				max-width: 1200px;
				margin: 0 auto;
				display: flex;
				justify-content: space-between;
				align-items: center;
				padding: 0 20px;
			}

			.logo {
				font-size: 24px;
				font-weight: 700;
				color: #000;
				text-decoration: none;
				letter-spacing: -0.5px;
			}

			.nav {
				display: flex;
				gap: 30px;
			}

			.nav a {
				color: #000;
				text-decoration: none;
				font-size: 14px;
				font-weight: 500;
				text-transform: uppercase;
				letter-spacing: 1px;
				transition: color 0.3s ease;
			}

			.nav a:hover {
				color: #666;
			}

			.hero-section {
				text-align: center;
				margin: 100px 0 60px 0;
				pointer-events: auto;
				max-width: 800px;
				/* readability over animated background */
				background: rgba(255, 255, 255, 0.92);
				/* background: url('../assets/images/cloud2.png') no-repeat center center; */
				background-size: cover;
				backdrop-filter: blur(6px);
				border: 1px solid #000;
				border-radius: 10px;
				box-shadow: 0 10px 30px rgba(0,0,0,0.12);
				padding: 24px;
			}

			.hero-copy {
				font-size: 18px;
				color: #333;
				line-height: 1.6;
				margin: 0 0 40px 0;
				font-weight: 400;
			}

			.newsletter-section {
				background: #f8f8f8;
				border: 1px solid #ddd;
				border-radius: 8px;
				padding: 30px;
				margin: 0 auto;
				text-align: center;
				pointer-events: auto;
				max-width: 600px;
				color: #000;
			}

			.newsletter-title {
				font-size: 16px;
				font-weight: 700;
				color: #000;
				margin: 0 0 15px 0;
				text-transform: uppercase;
				letter-spacing: 1px;
			}

			.newsletter-form {
				display: flex;
				gap: 10px;
				justify-content: center;
				align-items: center;
				flex-wrap: wrap;
			}

			.newsletter-input {
				padding: 12px 16px;
				border: 1px solid #ccc;
				border-radius: 4px;
				font-size: 14px;
				min-width: 250px;
				font-family: inherit;
			}

			.newsletter-button {
				background: #c0c0c0;
				color: #000000;
				padding: 12px 24px;
				font-size: 14px;
				font-weight: 700;
				letter-spacing: 0.02em;
				text-transform: none;
				border-radius: 0;
				cursor: pointer;
				border: 2px solid #ffffff;
				border-right-color: #404040;
				border-bottom-color: #404040;
				box-shadow:
					inset 1px 1px 0 #dfdfdf,
					inset -1px -1px 0 #808080,
					0 0 0 1px #000000;
				transition: background-color .12s ease;
			}

			.newsletter-button:hover {
				background: #dcdcdc;
			}

			.newsletter-button:active {
				background: #b5b5b5;
				border-color: #404040;
				border-right-color: #ffffff;
				border-bottom-color: #ffffff;
				box-shadow:
					inset -1px -1px 0 #dfdfdf,
					inset 1px 1px 0 #808080,
					0 0 0 1px #000000;
			}

			.articles-section {
				width: 100%;
				/* max-width: 1200px; */
				box-shadow: 0 -2px 10px 0 rgba(0, 0, 0, 0.479);
				pointer-events: auto;
				background-color: #ffffff;
				padding: 40px 20px;
				/* background: url('../assets/images/clouds.png') no-repeat center center; */
				/* background-size: cover; */
			}

			.section-title {
				font-size: 64px;
				font-weight: 700;
				color: #000;
				margin-top: 40px;
				margin-bottom: 40px;
				/* padding-top: 40px; */
				padding-bottom: 40px;
				text-align: center;
				letter-spacing: -0.5px;
			}

			#main-title {
				font-size: 60px;
				font-weight: 300;
				color: #000000;
				margin: 0 0 16px 0;
				font-family: 'Arial Narrow', monospace;
				line-height: 1.1;
				display: flex;
				align-items: baseline;
				justify-content: center;
				flex-wrap: wrap;
				letter-spacing: -1px;
			}

			.letter {
				display: inline-block;
				transition: transform 0.3s ease;
			}

			.letter.small {
				font-size: 0.6em;
				font-weight: normal;
			}

			.letter.medium {
				font-size: 0.8em;
				font-weight:900;
			}
			.letter.medium-light {
				font-size: 0.8em;
				font-weight:100;
			}

			.letter.big {
				font-size: 1em;
				font-weight: 900;
			}

			.letter.huge {
				font-size: 1.3em;
				font-weight: 900;
			}

			#subtitle {
				font-size: 20px;
				color: black;
				margin: 0 0 32px 0;
				line-height: 1.5;
				font-weight: 400;
				font-style: italic;
				text-shadow: 0 1px 0 rgba(255,255,255,0.6);
			}

			.articles-grid {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
				gap: 32px;
				max-width: 1200px;
				margin: 0 auto;
				width: 100%;
				pointer-events: auto;
				padding: 0 20px;
			}

			.article-card {
				background-color: #ffffff;
				background: linear-gradient(to bottom, #000000 0%, #ffffff 5%, #ffffff 95%, #000000 100%);
				border: 1px solid black;
				border-radius: 8px;
				border-top-right-radius: 0;
				border-bottom-left-radius: 0;
				position: relative;
				overflow: hidden;
				transition: transform 0.3s ease, box-shadow 0.3s ease;
				cursor: pointer;
				text-decoration: none;
				color: inherit;
			}

			.article-card::before {
				content: '';
				text-align: right;
				background-color: black;
				padding: 0 12px;
				font-size: 8px;
				display: flex;
				align-items: center;
				justify-content: right;
				position: absolute;
				border-radius: 10px 10px 0 0;
				top: -20px;
				right: -1px;
				border: none;
				width:120px;
				height: 21px;
				box-sizing: border-box;
				z-index: -1;
				clip-path: polygon(18% 0, 100% 0, 100% 100%, 0% 100%);
			}

			.article-card::after {
				content: '';
				text-align: right;
				background-color: black;
				padding: 0 12px;
				font-size: 8px;
				display: flex;
				align-items: center;
				justify-content: right;
				position: absolute;
				border-radius: 0px 0px 10px 10px;
				bottom: -20px;
				left: -1px;
				border: none;
				width:120px;
				height: 21px;
				box-sizing: border-box;
				z-index: -1;
				clip-path: polygon( 0 0, 100% 0, 82% 100%, 0% 100%);
			}

			.article-card:hover {
				transform: translateY(-5px);
				box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
			}

			.article-preview {
				width: 100%;
				height: 200px;
				background-size: cover;
				background-position: center;
				background-repeat: no-repeat;
				position: relative;
			}

			.article-preview::after {
				content: '';
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: linear-gradient(to bottom, transparent 0%, rgba(0,0,0,0.1) 100%);
			}

			.article-content {
				padding: 28px;
			}

			.article-category {
				font-size: 11px;
				font-weight: 600;
				color: #555;
				text-transform: uppercase;
				letter-spacing: 1.5px;
			}

			.article-title {
				font-size: 30px;
				font-weight: 700;
				color: #000;
				line-height: 1.4;
				letter-spacing: -0.3px;
				margin-bottom: 4px;
			}

			.article-excerpt {
				font-size: 15px;
				color: #444;
				line-height: 1.6;
				margin: 0 0 20px 0;
				font-weight: 400;
			}

			.article-meta {
				display: flex;
				justify-content: space-between;
				align-items: center;
				font-size: 13px;
				color: #777;
				margin-top: 4px;
			}

			.article-date {
				font-weight: 600;
				color: #666;
			}

			.article-read-time {
				font-style: italic;
				color: #888;
				font-weight: 400;
			}


			.hidden {
				display: none !important;
			}
			
			.cloud-image {
				position: fixed;
				z-index: 150;
				pointer-events: none;
				transform-origin: center center;
				opacity: 1;
				filter: brightness(1.1) contrast(1.1);
			}
			
			.hud-scanner {
				position: fixed;
				width: 20px;
				height: 20px;
				border: 2px solid #4a90e2;
				background: rgba(74, 144, 226, 0.15);
				z-index: 160;
				pointer-events: none;
				transition: all 0.4s ease;
				box-shadow: 
					0 0 8px rgba(74, 144, 226, 0.4),
					inset 0 0 8px rgba(74, 144, 226, 0.2);
			}
			
			.hud-scanner.scanning {
				border-color: #2ecc71;
				background: rgba(46, 204, 113, 0.15);
				box-shadow: 
					0 0 15px rgba(46, 204, 113, 0.6),
					inset 0 0 10px rgba(46, 204, 113, 0.3);
			}
			
			.hud-scanner::before {
				content: '';
				position: absolute;
				top: 50%;
				left: 50%;
				width: 6px;
				height: 6px;
				background: currentColor;
				border-radius: 50%;
				transform: translate(-50%, -50%);
				box-shadow: 0 0 4px currentColor;
			}
			
			.hud-scanner::after {
				content: attr(data-status);
				position: absolute;
				bottom: -35px;
				right: -50px;
				font-family: 'Epmarugo', monospace;
				font-size: 10px;
				color: black;
				white-space: nowrap;
				font-weight: bold;
				text-shadow: 1px 1px 0px white, -1px -1px 0px white, 1px -1px 0px white, -1px 1px 0px white;
			}
			
			.hud-scanner-frame {
				position: absolute;
				top: -3px;
				left: -3px;
				right: -3px;
				bottom: -3px;
				border: 1px solid currentColor;
				opacity: 0.6;
				pointer-events: none;
			}
			
			.hud-scanner-corners {
				position: absolute;
				top: -6px;
				left: -6px;
				right: -6px;
				bottom: -6px;
				pointer-events: none;
			}
			
			.hud-scanner-corners::before,
			.hud-scanner-corners::after {
				content: '';
				position: absolute;
				width: 8px;
				height: 8px;
				border: 1px solid black;
				opacity: 0.8;
			}
			
			.hud-scanner-corners::before {
				top: 0;
				left: 0;
				border-right: none;
				border-bottom: none;
			}
			
			.hud-scanner-corners::after {
				bottom: 0;
				right: 0;
				border-left: none;
				border-top: none;
			}
		</style>
	</head>
	<body>
		<header class="header">
			<div class="header-content">
				<a href="#" class="logo">EX RESEARCH</a>
				<nav class="nav">
					<a href="../articles/index.html">Home</a>
					<a href="../about/index.html">About</a>
					<a href="../contact/index.html">Contact</a>
				</nav>
			</div>
		</header>

		<div id="homepage-ui">
			<div class="hero-section">
				<h1 id="main-title">
					<span class="letter medium-light">EX</span>
					<span class="letter small">&nbsp;</span>
					<span class="letter medium">R</span><span class="letter medium">e</span><span class="letter medium">s</span><span class="letter medium">e</span><span class="letter medium">a</span><span class="letter medium">r</span><span class="letter medium">c</span><span class="letter medium">h</span>
				</h1>
				<p id="subtitle">EX Research helps you stay ahead of the internet.</p>
				
				<div class="hero-copy">
					<p>We're a plugged-in collective of researchers and strategists who know what's real online. We're obsessed with new forms of creativity. The places where games, music, AI, and shitposting mingle and mutate. We treat dumb stuff like art.</p>
				</div>

				<div class="newsletter-section">
					<h3 class="newsletter-title">Subscribe to our newsletter</h3>
					<p>Weekly download of future-culture picks and deep-internet insights.</p>
					<form class="newsletter-form">
						<input type="email" class="newsletter-input" placeholder="Enter your email" required>
						<button type="submit" class="newsletter-button">Subscribe</button>
					</form>
				</div>
			</div>

			<div class="articles-section">
				<h2 class="section-title">Recent Posts</h2>
				<div class="articles-grid" id="articles-grid">
					<!-- Articles will be populated by JavaScript -->
				</div>
			</div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';

			import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
			import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
			import { SAOPass } from 'three/addons/postprocessing/SAOPass.js';
			import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
			import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

			let container, stats;
			let camera, scene, renderer;
			let composer, renderPass, saoPass, ditheringPass;
			let group;
			
			// 2D Chatbox overlay variables
			let overlayCanvas, overlayCtx;
			let chatboxes2D = [];
			let customFontLoaded = false;
			let lastSpawnTime = 0;
			let spawnInterval = 1200; // Spawn new chatbox every 1.2 seconds
			let pixelScale = 2; // How much to scale down for pixelation
			
			// Cloud image system
			let cloudImages = [];
			let lastCloudSpawnTime = 0;
			let cloudSpawnInterval = 3000; // Spawn every 3 seconds
			
			// Wandering HUD scanner system
			let wanderingScanners = [];
			let maxScanners = 3;
			let detectionDistance = 80;

			// Sample articles data
			const articles = [
				{
					id: 1,
					title: "Black magic",
					category: "Newsletter",
					excerpt: "Weekly download of future-culture picks and deep-internet insights.",
					date: "Oct 7, 2025",
					readTime: "7 min",
					previewImage: "assets/ex1.jpg",
					link: "../article/index.html"
				},
				{
					id: 2,
					title: "Actual anomalies",
					category: "Newsletter",
					excerpt: "Weekly download of future-culture picks and deep-internet insights.",
					date: "Aug 31, 2025",
					readTime: "6 min",
					previewImage: "assets/ex2.jpg",
					link: "../article/index.html"
				},
				{
					id: 3,
					title: "Safety last",
					category: "Newsletter",
					excerpt: "Weekly download of future-culture picks and deep-internet insights.",
					date: "Aug 17, 2025",
					readTime: "8 min",
					previewImage: "assets/ex3.jpg",
					link: "../article/index.html"
				},
				{
					id: 4,
					title: "Supper man wavers",
					category: "Newsletter",
					excerpt: "Weekly download of future-culture picks and deep-internet insights.",
					date: "Aug 3, 2025",
					readTime: "7 min",
					previewImage: "assets/ex4.jpg",
					link: "../article/index.html"
				},
				{
					id: 5,
					title: "Playing goo-goo babies with your life on the line",
					category: "Newsletter",
					excerpt: "Weekly download of future-culture picks and deep-internet insights.",
					date: "Jul 21, 2025",
					readTime: "7 min",
					previewImage: "assets/ex5.png",
					link: "../article/index.html"
				},
				{
					id: 6,
					title: "Coconut dogs",
					category: "Newsletter",
					excerpt: "Weekly download of future-culture picks and deep-internet insights.",
					date: "Jun 30, 2025",
					readTime: "3 min",
					previewImage: "assets/ex6.png",
					link: "../article/index.html"
				}
			];

			// Dithering shader
			const DitheringShader = {
				uniforms: {
					'tDiffuse': { value: null },
					'resolution': { value: new THREE.Vector2() },
					'colorNum': { value: 4.0 },
					'pixelSize': { value: 2.0 }
				},

				vertexShader: `
					varying vec2 vUv;
					void main() {
						vUv = uv;
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					}
				`,

				fragmentShader: `
					uniform sampler2D tDiffuse;
					uniform vec2 resolution;
					uniform float colorNum;
					uniform float pixelSize;
					varying vec2 vUv;

					const float bayerMatrix8x8[64] = float[64](
						0.0/ 64.0, 48.0/ 64.0, 12.0/ 64.0, 60.0/ 64.0,  3.0/ 64.0, 51.0/ 64.0, 15.0/ 64.0, 63.0/ 64.0,
						32.0/ 64.0, 16.0/ 64.0, 44.0/ 64.0, 28.0/ 64.0, 35.0/ 64.0, 19.0/ 64.0, 47.0/ 64.0, 31.0/ 64.0,
						8.0/ 64.0, 56.0/ 64.0,  4.0/ 64.0, 52.0/ 64.0, 11.0/ 64.0, 59.0/ 64.0,  7.0/ 64.0, 55.0/ 64.0,
						40.0/ 64.0, 24.0/ 64.0, 36.0/ 64.0, 20.0/ 64.0, 43.0/ 64.0, 27.0/ 64.0, 39.0/ 64.0, 23.0/ 64.0,
						2.0/ 64.0, 50.0/ 64.0, 14.0/ 64.0, 62.0/ 64.0,  1.0/ 64.0, 49.0/ 64.0, 13.0/ 64.0, 61.0/ 64.0,
						34.0/ 64.0, 18.0/ 64.0, 46.0/ 64.0, 30.0/ 64.0, 33.0/ 64.0, 17.0/ 64.0, 45.0/ 64.0, 29.0/ 64.0,
						10.0/ 64.0, 58.0/ 64.0,  6.0/ 64.0, 54.0/ 64.0,  9.0/ 64.0, 57.0/ 64.0,  5.0/ 64.0, 53.0/ 64.0,
						42.0/ 64.0, 26.0/ 64.0, 38.0/ 64.0, 22.0/ 64.0, 41.0/ 64.0, 25.0/ 64.0, 37.0/ 64.0, 21.0 / 64.0
					);

					vec3 dither(vec2 uv, vec3 color) {
						int x = int(uv.x * resolution.x) % 8;
						int y = int(uv.y * resolution.y) % 8;
						float threshold = bayerMatrix8x8[y * 8 + x] - 0.25;

						color.rgb += threshold;
						color.r = floor(color.r * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);
						color.g = floor(color.g * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);
						color.b = floor(color.b * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);

						return color;
					}

					void main() {
						vec2 normalizedPixelSize = pixelSize / resolution;  
						vec2 uvPixel = normalizedPixelSize * floor(vUv / normalizedPixelSize);

						vec4 color = texture2D(tDiffuse, uvPixel);
						color.rgb = dither(uvPixel, color.rgb);

						gl_FragColor = color;
					}
				`
			};

			function createOverlayCanvas() {
				overlayCanvas = document.createElement('canvas');
				overlayCanvas.style.position = 'fixed';
				overlayCanvas.style.top = '0';
				overlayCanvas.style.left = '0';
				overlayCanvas.style.pointerEvents = 'none';
				overlayCanvas.style.zIndex = '100';
				overlayCanvas.style.imageRendering = 'pixelated';
				overlayCanvas.style.imageRendering = 'crisp-edges';
				overlayCanvas.style.overflow = 'hidden';
				document.body.appendChild(overlayCanvas);
				
				overlayCtx = overlayCanvas.getContext('2d');
				overlayCtx.imageSmoothingEnabled = false;
				overlayCtx.webkitImageSmoothingEnabled = false;
				overlayCtx.mozImageSmoothingEnabled = false;
				overlayCtx.msImageSmoothingEnabled = false;
				
				resizeOverlayCanvas();
				
				loadCustomFont();
				create2DChatboxes();
			}

			function loadCustomFont() {
				const font = new FontFace('Epmarugo', 'url(assets/epmarugo.ttf)');
				font.load().then(function(loadedFont) {
					document.fonts.add(loadedFont);
					customFontLoaded = true;
				}).catch(function(error) {
					console.warn('Custom font failed to load:', error);
					customFontLoaded = false;
				});
			}

			function resizeOverlayCanvas() {
				const viewportWidth = document.documentElement.clientWidth;
				const viewportHeight = document.documentElement.clientHeight;
				
				overlayCanvas.width = Math.floor(viewportWidth / pixelScale);
				overlayCanvas.height = Math.floor(viewportHeight / pixelScale);
				
				overlayCanvas.style.width = viewportWidth + 'px';
				overlayCanvas.style.height = viewportHeight + 'px';
			}

			function create2DChatboxes() {
				chatboxes2D = [];
				
				const initialCount = 6 + Math.floor(Math.random() * 4);
				
				for (let i = 0; i < initialCount; i++) {
					const chatbox = createNewChatbox();
					const gridCols = Math.ceil(Math.sqrt(initialCount));
					const gridRows = Math.ceil(initialCount / gridCols);
					const col = i % gridCols;
					const row = Math.floor(i / gridCols);
					
					const cellWidth = (overlayCanvas.width / pixelScale) / gridCols;
					const cellHeight = (overlayCanvas.height / pixelScale) / gridRows;
					
					chatbox.x = (col * cellWidth) + (Math.random() * cellWidth * 0.8);
					chatbox.y = (row * cellHeight) + (Math.random() * cellHeight * 0.8);
					
					chatbox.x = Math.max(0, Math.min(chatbox.x, overlayCanvas.width / pixelScale - chatbox.width));
					chatbox.y = Math.max(0, Math.min(chatbox.y, overlayCanvas.height / pixelScale - chatbox.height));
					
					chatboxes2D.push(chatbox);
				}
			}

			function createNewChatbox(startX = null, speedTier = 'normal') {
				const baseWidth = 240;
				const baseHeight = 72;
				
				const scaledWidth = baseWidth / pixelScale;
				const scaledHeight = baseHeight / pixelScale;
				const scaledMargin = 80 / pixelScale;
				
				const x = startX !== null ? startX : overlayCanvas.width + scaledMargin/4;
				const caretMargin = 20 / pixelScale;
				const y = Math.random() * (overlayCanvas.height - scaledHeight - caretMargin);
				
				let baseVelocity, verticalDrift;
				switch (speedTier) {
					case 'superfast':
						baseVelocity = (-5 - Math.random() * 6) / pixelScale;
						verticalDrift = ((Math.random() - 0.5) * 1.5) / pixelScale;
						break;
					case 'fast':
						baseVelocity = (-3 - Math.random() * 3) / pixelScale;
						verticalDrift = ((Math.random() - 0.5) * 1.0) / pixelScale;
						break;
					case 'medium':
						baseVelocity = (-1.5 - Math.random() * 2) / pixelScale;
						verticalDrift = ((Math.random() - 0.5) * 0.6) / pixelScale;
						break;
					case 'slow':
						baseVelocity = (-0.8 - Math.random() * 1.2) / pixelScale;
						verticalDrift = ((Math.random() - 0.5) * 0.4) / pixelScale;
						break;
					default:
						baseVelocity = (-0.5 - Math.random() * 0.8) / pixelScale;
						verticalDrift = ((Math.random() - 0.5) * 0.2) / pixelScale;
						break;
				}
				
				return {
					x: x,
					y: y,
					vx: baseVelocity,
					vy: verticalDrift,
					width: scaledWidth,
					height: scaledHeight,
					text: 'EX Research',
					textStyles: generateRandomTextStyles(),
					styleUpdateTime: 0,
					speedTier: speedTier
				};
			}

			function generateRandomTextStyles() {
				const fragments = [
					{
						text: 'EX',
						bold: Math.random() > 0.5,
						sizeMultiplier: 0.8 + Math.random() * 0.6
					},
					{
						text: ' ',
						bold: false,
						sizeMultiplier: 1
					},
					{
						text: 'Research',
						bold: Math.random() > 0.5,
						sizeMultiplier: 0.8 + Math.random() * 0.6
					}
				];
				return fragments;
			}

			function createCloudImage() {
				const exNumber = Math.floor(Math.random() * 9) + 1;
				const img = document.createElement('img');
				img.src = `assets/ex${exNumber}.png`;
				img.className = 'cloud-image';
				
				const x = Math.random() * (window.innerWidth - 200) + 100;
				const y = Math.random() * (window.innerHeight - 200) + 100;
				
				const finalWidth = 150 + Math.random() * 300;
				const finalHeight = 100 + Math.random() * 200;
				
				img.style.left = x + 'px';
				img.style.top = y + 'px';
				img.style.width = '0px';
				img.style.height = '0px';
				img.style.transform = 'translate(-50%, -50%)';
				
				document.body.appendChild(img);
				
				const cloudData = {
					element: img,
					x: x,
					y: y,
					currentWidth: 0,
					currentHeight: 0,
					finalWidth: finalWidth,
					finalHeight: finalHeight,
					phase: 'scaling',
					startTime: performance.now(),
					scaleDuration: 200 + Math.random() * 300,
					scanner: null
				};
				
				return cloudData;
			}

			function createWanderingScanner() {
				const scanner = document.createElement('div');
				scanner.className = 'hud-scanner';
				
				const frame = document.createElement('div');
				frame.className = 'hud-scanner-frame';
				scanner.appendChild(frame);
				
				const corners = document.createElement('div');
				corners.className = 'hud-scanner-corners';
				scanner.appendChild(corners);
				
				const line = document.createElement('div');
				line.className = 'hud-scanner-line';
				scanner.appendChild(line);
				
				const startX = Math.random() * window.innerWidth;
				const startY = Math.random() * window.innerHeight;
				
				scanner.style.left = startX + 'px';
				scanner.style.top = startY + 'px';
				scanner.style.transform = 'translate(-50%, -50%)';
				scanner.style.width = '20px';
				scanner.style.height = '20px';
				scanner.setAttribute('data-status', 'Scanning');
				
				document.body.appendChild(scanner);
				
				const angle = Math.random() * Math.PI * 2;
				const speed = 1 + Math.random() * 1.5;
				
				const scannerData = {
					element: scanner,
					currentX: startX,
					currentY: startY,
					velocityX: Math.cos(angle) * speed,
					velocityY: Math.sin(angle) * speed,
					phase: 'wandering',
					lastDirectionChange: performance.now(),
					targetCloud: null,
					initialWidth: 20,
					initialHeight: 20
				};
				
				return scannerData;
			}

			function initializeWanderingScanners() {
				for (let i = 0; i < maxScanners; i++) {
					wanderingScanners.push(createWanderingScanner());
				}
			}

			function updateCloudImages(currentTime) {
				if (window.cloudControls && window.cloudControls.enabled && 
					currentTime - lastCloudSpawnTime > cloudSpawnInterval) {
					cloudImages.push(createCloudImage());
					lastCloudSpawnTime = currentTime;
				}
				
				cloudImages = cloudImages.filter(cloud => {
					const elapsed = currentTime - cloud.startTime;
					
					if (cloud.phase === 'scaling') {
						const progress = Math.min(elapsed / cloud.scaleDuration, 1);
						cloud.currentWidth = cloud.finalWidth * progress;
						cloud.currentHeight = cloud.finalHeight * progress;
						
						cloud.element.style.width = cloud.currentWidth + 'px';
						cloud.element.style.height = cloud.currentHeight + 'px';
						
						if (progress >= 1) {
							cloud.phase = 'ready';
							assignScannerToCloud(cloud);
						}
					} else if (cloud.phase === 'ready') {
						// Ready to be detected
					} else if (cloud.phase === 'being_scanned') {
						// Being scanned
					}
					
					return cloud.phase !== 'complete';
				});
			}

			function updateWanderingScanners(currentTime) {
				while (wanderingScanners.length < maxScanners) {
					wanderingScanners.push(createWanderingScanner());
				}
				
				wanderingScanners.forEach(scanner => {
					if (!scanner.element || !scanner.element.parentNode) return;
					
					if (scanner.phase === 'wandering') {
						scanner.currentX += scanner.velocityX;
						scanner.currentY += scanner.velocityY;
						
						if (scanner.currentX < 0 || scanner.currentX > window.innerWidth) {
							scanner.velocityX *= -1;
							scanner.currentX = Math.max(0, Math.min(window.innerWidth, scanner.currentX));
						}
						if (scanner.currentY < 0 || scanner.currentY > window.innerHeight) {
							scanner.velocityY *= -1;
							scanner.currentY = Math.max(0, Math.min(window.innerHeight, scanner.currentY));
						}
						
						if (currentTime - scanner.lastDirectionChange > 2000 + Math.random() * 3000) {
							const angle = Math.random() * Math.PI * 2;
							const speed = 1 + Math.random() * 1.5;
							scanner.velocityX = Math.cos(angle) * speed;
							scanner.velocityY = Math.sin(angle) * speed;
							scanner.lastDirectionChange = currentTime;
						}
					} else if (scanner.phase === 'targeting') {
						const cloud = scanner.targetCloud;
						if (!cloud || cloud.phase === 'complete') {
							scanner.phase = 'wandering';
							scanner.targetCloud = null;
							return;
						}
						
						const dx = cloud.x - scanner.currentX;
						const dy = cloud.y - scanner.currentY;
						const distance = Math.sqrt(dx * dx + dy * dy);
						
						if (distance > 5) {
							const moveSpeed = 10;
							scanner.currentX += (dx / distance) * moveSpeed;
							scanner.currentY += (dy / distance) * moveSpeed;
						} else {
							scanner.phase = 'scanning';
							scanner.scanStartTime = currentTime;
							scanner.growthStartTime = currentTime;
							scanner.targetWidth = cloud.finalWidth;
							scanner.targetHeight = cloud.finalHeight;
							scanner.element.classList.add('scanning');
							scanner.element.setAttribute('data-status', 'Identified');
						}
						
					} else if (scanner.phase === 'scanning') {
						const elapsed = currentTime - scanner.scanStartTime;
						const growthElapsed = currentTime - scanner.growthStartTime;
						
						if (growthElapsed < 300) {
							const growthProgress = growthElapsed / 300;
							const easeProgress = 1 - Math.pow(1 - growthProgress, 3);
							
							const currentWidth = scanner.initialWidth + (scanner.targetWidth - scanner.initialWidth) * easeProgress;
							const currentHeight = scanner.initialHeight + (scanner.targetHeight - scanner.initialHeight) * easeProgress;
							
							scanner.element.style.width = currentWidth + 'px';
							scanner.element.style.height = currentHeight + 'px';
						}
						
						if (elapsed > 800) {
							scanner.targetCloud.element.remove();
							scanner.targetCloud.phase = 'complete';
							
							scanner.phase = 'returning';
							scanner.returnStartTime = currentTime;
							scanner.element.classList.remove('scanning');
						}
						
					} else if (scanner.phase === 'returning') {
						const elapsed = currentTime - scanner.returnStartTime;
						if (elapsed < 200) {
							const shrinkProgress = elapsed / 200;
							const currentWidth = scanner.targetWidth - (scanner.targetWidth - scanner.initialWidth) * shrinkProgress;
							const currentHeight = scanner.targetHeight - (scanner.targetHeight - scanner.initialHeight) * shrinkProgress;
							
							scanner.element.style.width = currentWidth + 'px';
							scanner.element.style.height = currentHeight + 'px';
						} else {
							scanner.element.style.width = scanner.initialWidth + 'px';
							scanner.element.style.height = scanner.initialHeight + 'px';
							scanner.element.setAttribute('data-status', 'Scanning');
							scanner.phase = 'wandering';
							scanner.targetCloud = null;
							
							const angle = Math.random() * Math.PI * 2;
							const speed = 1 + Math.random() * 1.5;
							scanner.velocityX = Math.cos(angle) * speed;
							scanner.velocityY = Math.sin(angle) * speed;
						}
					}
					
					scanner.element.style.left = scanner.currentX + 'px';
					scanner.element.style.top = scanner.currentY + 'px';
				});
			}

			function assignScannerToCloud(cloud) {
				let nearestScanner = null;
				let nearestDistance = Infinity;
				
				wanderingScanners.forEach(scanner => {
					if (scanner.phase === 'wandering') {
						const dx = cloud.x - scanner.currentX;
						const dy = cloud.y - scanner.currentY;
						const distance = Math.sqrt(dx * dx + dy * dy);
						
						if (distance < nearestDistance) {
							nearestDistance = distance;
							nearestScanner = scanner;
						}
					}
				});
				
				if (nearestScanner) {
					nearestScanner.phase = 'targeting';
					nearestScanner.targetCloud = cloud;
					cloud.phase = 'being_scanned';
				}
			}

			function drawChatboxes() {
				if (!overlayCtx) return;
				
				overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
				
				const currentTime = performance.now();
				
				updateCloudImages(currentTime);
				updateWanderingScanners(currentTime);
				
				const speed = window.chatboxControls ? window.chatboxControls.speed : 1.0;
				const connectionDistance = window.chatboxControls ? window.chatboxControls.connectionDistance * 12 : 40;
				
				if (currentTime - lastSpawnTime > spawnInterval) {
					chatboxes2D.push(createNewChatbox(null, 'normal'));
					lastSpawnTime = currentTime;
				}
				
				chatboxes2D = chatboxes2D.filter(chatbox => {
					chatbox.x += chatbox.vx * speed;
					chatbox.y += chatbox.vy * speed;
					
					if (currentTime - chatbox.styleUpdateTime > 2000 + Math.random() * 2000) {
						chatbox.textStyles = generateRandomTextStyles();
						chatbox.styleUpdateTime = currentTime;
					}
					
					const caretMargin = 20 / pixelScale;
					if (chatbox.y < 0) {
						chatbox.y = 0;
						chatbox.vy = Math.abs(chatbox.vy) * 0.5;
					}
					if (chatbox.y > overlayCanvas.height - chatbox.height - caretMargin) {
						chatbox.y = overlayCanvas.height - chatbox.height - caretMargin;
						chatbox.vy = -Math.abs(chatbox.vy) * 0.5;
					}
					
					return chatbox.x > -chatbox.width - 20;
				});
				
				overlayCtx.strokeStyle = 'black';
				overlayCtx.lineWidth = Math.max(1, Math.round(2 / pixelScale));
				
				for (let i = 0; i < chatboxes2D.length; i++) {
					for (let j = i + 1; j < chatboxes2D.length; j++) {
						const dx = (chatboxes2D[i].x + chatboxes2D[i].width/2) - (chatboxes2D[j].x + chatboxes2D[j].width/2);
						const dy = (chatboxes2D[i].y + chatboxes2D[i].height/2) - (chatboxes2D[j].y + chatboxes2D[j].height/2);
						const distance = Math.sqrt(dx * dx + dy * dy);
						
						if (distance < connectionDistance) {
							overlayCtx.beginPath();
							overlayCtx.moveTo(chatboxes2D[i].x + chatboxes2D[i].width/2, chatboxes2D[i].y + chatboxes2D[i].height/2);
							overlayCtx.lineTo(chatboxes2D[j].x + chatboxes2D[j].width/2, chatboxes2D[j].y + chatboxes2D[j].height/2);
							overlayCtx.stroke();
						}
					}
				}
				
				chatboxes2D.forEach(chatbox => {
					drawSpeechBubble(chatbox);
				});
			}

			function drawSpeechBubble(chatbox) {
				const baseCaretSize = 20;
				const baseCaretOffset = 32;
				
				const caretSize = baseCaretSize / pixelScale;
				const caretX = chatbox.x + (baseCaretOffset / pixelScale);
				const caretY = chatbox.y + chatbox.height;

				const isFF7Style = window.chatboxControls && window.chatboxControls.style === 'ff7';

				if (isFF7Style) {
					const gradient = overlayCtx.createLinearGradient(
						chatbox.x, chatbox.y, 
						chatbox.x, chatbox.y + chatbox.height
					);
					gradient.addColorStop(0, '#1e3a5f');
					gradient.addColorStop(0.5, '#0f1f3d');
					gradient.addColorStop(1, '#061426');
					
					overlayCtx.fillStyle = gradient;
					overlayCtx.strokeStyle = '#4a6fa5';
					overlayCtx.lineWidth = Math.max(1, Math.round(2 / pixelScale));
				} else {
					overlayCtx.fillStyle = 'white';
					overlayCtx.strokeStyle = 'black';
					overlayCtx.lineWidth = Math.max(1, Math.round(4 / pixelScale));
				}

				overlayCtx.beginPath();
				overlayCtx.rect(chatbox.x, chatbox.y, chatbox.width, chatbox.height);
				overlayCtx.moveTo(caretX - caretSize, caretY);
				overlayCtx.lineTo(caretX + caretSize, caretY);
				overlayCtx.lineTo(caretX, caretY + caretSize);
				overlayCtx.closePath();
				overlayCtx.fill();

				overlayCtx.beginPath();
				overlayCtx.moveTo(chatbox.x, chatbox.y);
				overlayCtx.lineTo(chatbox.x + chatbox.width, chatbox.y);
				overlayCtx.lineTo(chatbox.x + chatbox.width, chatbox.y + chatbox.height);
				overlayCtx.lineTo(caretX + caretSize, caretY);
				overlayCtx.moveTo(caretX - caretSize, caretY);
				overlayCtx.lineTo(chatbox.x, caretY);
				overlayCtx.lineTo(chatbox.x, chatbox.y);
				overlayCtx.stroke();

				overlayCtx.beginPath();
				overlayCtx.moveTo(caretX - caretSize, caretY);
				overlayCtx.lineTo(caretX, caretY + caretSize);
				overlayCtx.lineTo(caretX + caretSize, caretY);
				overlayCtx.stroke();
				
				overlayCtx.fillStyle = isFF7Style ? 'white' : 'black';
				overlayCtx.textBaseline = 'middle';
				
				const textBaseFontSize = chatbox.height * 0.4;
				const fontFamily = customFontLoaded ? 'Epmarugo' : 'monospace';
				
				let totalWidth = 0;
				chatbox.textStyles.forEach(fragment => {
					const fontSize = textBaseFontSize * fragment.sizeMultiplier;
					const weight = fragment.bold ? 'bold' : 'normal';
					overlayCtx.font = `${weight} ${fontSize}px ${fontFamily}`;
					totalWidth += overlayCtx.measureText(fragment.text).width;
				});
				
				const maxWidth = chatbox.width * 0.9;
				const textScale = totalWidth > maxWidth ? maxWidth / totalWidth : 1;
				
				let currentX = chatbox.x + (chatbox.width - (totalWidth * textScale)) / 2;
				const textY = chatbox.y + chatbox.height / 2;
				
				chatbox.textStyles.forEach(fragment => {
					const fontSize = (textBaseFontSize * fragment.sizeMultiplier) * textScale;
					const weight = fragment.bold ? 'bold' : 'normal';
					overlayCtx.font = `${weight} ${fontSize}px ${fontFamily}`;
					
					overlayCtx.fillText(fragment.text, currentX, textY);
					currentX += overlayCtx.measureText(fragment.text).width;
				});
			}

			function renderArticles() {
				const articlesGrid = document.getElementById('articles-grid');
				
				articles.forEach(article => {
					// Outer link wrapper so the whole window is clickable
					const link = document.createElement('a');
					link.href = article.link;
					link.className = 'article-card windowized';
					link.style.textDecoration = 'none';
					link.style.color = 'inherit';

					// Pixel window chrome container
					const windowEl = document.createElement('div');
					windowEl.className = 'agency-card pixel-window';

					// Titlebar
					const titlebar = document.createElement('div');
					titlebar.className = 'window-titlebar';
					const title = document.createElement('div');
					title.className = 'window-title';
					title.textContent = article.title;
					const controls = document.createElement('div');
					controls.className = 'window-controls';
					controls.innerHTML = `
						<div class="window-control" title="Minimize"><span>–</span></div>
						<div class="window-control" title="Resize"><span>□</span></div>
						<div class="window-control" title="Close"><span>×</span></div>
					`;
					titlebar.appendChild(title);
					titlebar.appendChild(controls);


					// Body (preview + content)
					const body = document.createElement('div');
					body.className = 'card-body';
					body.innerHTML = `
						<div class="article-preview" style="background-image: url('${article.previewImage}')"></div>
						<div class="article-content">
							<div class="article-category">${article.category}</div>
							<h3 class="article-title">${article.title}</h3>
							<p class="article-excerpt">${article.excerpt}</p>
							<div class="article-meta">
								<span class="article-date">${article.date}</span>
								<span class="article-read-time">${article.readTime}</span>
							</div>
						</div>
					`;

					// Status bar and scanlines
					const scanlines = document.createElement('div');
					scanlines.className = 'window-scanlines';
					const status = document.createElement('div');
					status.className = 'status-bar';
					status.innerHTML = `<span>Pixel UI v1.0</span><span>${article.date}</span>`;

					// Assemble
					windowEl.appendChild(titlebar);
					windowEl.appendChild(body);
					windowEl.appendChild(scanlines);
					// windowEl.appendChild(status);
					link.appendChild(windowEl);
					articlesGrid.appendChild(link);
				});
			}

			function setupNewsletterForm() {
				const form = document.querySelector('.newsletter-form');
				if (form) {
					form.addEventListener('submit', function(e) {
						e.preventDefault();
						const email = form.querySelector('.newsletter-input').value;
						if (email) {
							alert('Thanks for subscribing! We\'ll be in touch soon.');
							form.querySelector('.newsletter-input').value = '';
						}
					});
				}
			}

			function setupNavigation() {
				// Navigation is now handled by direct links
			}

			init();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				const width = document.documentElement.clientWidth;
				const height = document.documentElement.clientHeight;

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xffffff, 1 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );
				// Ensure the WebGL canvas never captures scroll or clicks
				renderer.domElement.style.pointerEvents = 'none';

				camera = new THREE.PerspectiveCamera( 65, width / height, 3, 10 );
				camera.position.z = 7;

				scene = new THREE.Scene();

				group = new THREE.Object3D();
				scene.add( group );

				const light = new THREE.PointLight( 0xefffef, 500 );
				light.position.z = 10;
				light.position.y = - 10;
				light.position.x = - 10;
				scene.add( light );

				const light2 = new THREE.PointLight( 0xffefef, 500 );
				light2.position.z = 10;
				light2.position.x = - 10;
				light2.position.y = 10;
				scene.add( light2 );

				const light3 = new THREE.PointLight( 0xefefff, 500 );
				light3.position.z = 10;
				light3.position.x = 10;
				light3.position.y = - 10;
				scene.add( light3 );

				const light4 = new THREE.AmbientLight( 0xffffff, 0.2 );
				scene.add( light4 );

				const geometry = new THREE.SphereGeometry( 3, 48, 24 );

				for ( let i = 0; i < 120; i ++ ) {

					const material = new THREE.MeshStandardMaterial();
					material.roughness = 0.5 * Math.random() + 0.25;
					material.metalness = 0;
					material.color.setHSL( Math.random(), 1.0, 0.3 );

					const mesh = new THREE.Mesh( geometry, material );
					mesh.position.x = Math.random() * 4 - 2;
					mesh.position.y = Math.random() * 4 - 2;
					mesh.position.z = Math.random() * 4 - 2;
					mesh.rotation.x = Math.random();
					mesh.rotation.y = Math.random();
					mesh.rotation.z = Math.random();

					mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 0.2 + 0.05;
					group.add( mesh );

				}

				createOverlayCanvas();
				initializeWanderingScanners();
				renderArticles();
				setupNewsletterForm();
				setupNavigation();
				
				setTimeout(() => {
					if (cloudImages.length === 0) {
						cloudImages.push(createCloudImage());
					}
				}, 100);

				composer = new EffectComposer( renderer );
				renderPass = new RenderPass( scene, camera );
				composer.addPass( renderPass );
				saoPass = new SAOPass( scene, camera );
				
				saoPass.params.output = SAOPass.OUTPUT.Default;
				saoPass.params.saoBias = 0.5;
				saoPass.params.saoIntensity = 0.42;
				saoPass.params.saoScale = 6;
				saoPass.params.saoKernelRadius = 100;
				saoPass.params.saoMinResolution = 0;
				saoPass.params.saoBlur = false;
				saoPass.params.saoBlurRadius = 8;
				saoPass.params.saoBlurStdDev = 4;
				saoPass.params.saoBlurDepthCutoff = 0.01;
				
				composer.addPass( saoPass );
				
				ditheringPass = new ShaderPass( DitheringShader );
				ditheringPass.uniforms.resolution.value.set( window.innerWidth, window.innerHeight );
				ditheringPass.enabled = false;
				composer.addPass( ditheringPass );
				
				const outputPass = new OutputPass();
				composer.addPass( outputPass );

				window.chatboxControls = {
					visible: true,
					speed: 2.0,
					connectionDistance: 12.0,
					spawnRate: 2.0,
					pixelation: 2,
					style: 'classic'
				};

				window.cloudControls = {
					enabled: true,
					spawnRate: 0.5,
					scannerCount: 4
				};
				
				window.cloudDebug = {
					status: 'Waiting...'
				};

				window.addEventListener( 'resize', onWindowResize );

			// Add responsive typography styles
			const style = document.createElement('style');
			style.textContent = `
				@media (max-width: 768px) {
					.article-title {
						font-size: 20px !important;
						line-height: 1.3 !important;
					}
					.article-content {
						padding: 24px !important;
					}
					.articles-grid {
						grid-template-columns: 1fr !important;
						gap: 24px !important;
						padding: 0 16px !important;
					}
				}
				
				@media (max-width: 480px) {
					.article-title {
						font-size: 18px !important;
					}
					.article-excerpt {
						font-size: 14px !important;
					}
					.article-content {
						padding: 20px !important;
					}
				}
			`;
			document.head.appendChild(style);

			}

			function onWindowResize() {

				const width = document.documentElement.clientWidth || 1;
				const height = document.documentElement.clientHeight || 1;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();
				renderer.setSize( width, height );

				composer.setSize( width, height );
				
				ditheringPass.uniforms.resolution.value.set( width, height );
				
				if ( overlayCanvas ) {
					resizeOverlayCanvas();
				}
			}

			function animate() {
				render();
			}

			function render() {

				const timer = performance.now();
				group.rotation.x = timer * 0.0002;
				group.rotation.y = timer * 0.0001;

				if ( window.chatboxControls && window.chatboxControls.visible ) {
					drawChatboxes();
				}

				composer.render();

			}

		</script>
	</body>
</html>
