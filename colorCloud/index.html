<!DOCTYPE html>
<html lang="en">
	<head>
		<title>EX Research</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<link rel="stylesheet" href="https://unpkg.com/7.css">
		<style>

			@font-face {
				font-family: 'ff7';
				src: url('assets/Final_Fantasy_VII.ttf') format('truetype');
			}

			html, body {
				margin: 0;
				padding: 0;
				overflow: hidden;
				width: 100%;
				height: 100%;
			}
			
			#homepage-ui {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				z-index: 200;
				pointer-events: none;
				font-family: 'Arial Narrow', monospace;
			}

			.windows-dialog {
				max-width: 400px;
				width: 90%;
				pointer-events: auto;
				animation: windowPopIn 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
				transform: scale(0);
				animation-delay: 0.3s;
			}

			.window-body {
				padding: 16px;
				text-align: center;
			}
			
			#main-title {
				font-size: 48px;
				font-weight: bold;
				color: black;
				margin: 0 0 16px 0;
				font-family: 'Arial Narrow', monospace;
				line-height: 1.1;
				display: flex;
				align-items: baseline;
				justify-content: center;
				flex-wrap: wrap;
			}

			.letter {
				display: inline-block;
				transition: transform 0.3s ease;
			}

			.letter.small {
				font-size: 0.6em;
				font-weight: normal;
			}

			.letter.medium {
				font-size: 0.8em;
				font-weight:900;
			}
			.letter.medium-light {
				font-size: 0.8em;
				font-weight:100;
			}

			.letter.big {
				font-size: 1em;
				font-weight: 900;
			}

			.letter.huge {
				font-size: 1.3em;
				font-weight: 900;
			}

			.letter:hover {
				transform: scale(1.2) rotate(-5deg);
				color: #0066cc;
			}

			@keyframes windowPopIn {
				0% {
					transform: scale(0);
					opacity: 0;
				}
				50% {
					transform: scale(1.05);
					opacity: 1;
				}
				100% {
					transform: scale(1);
					opacity: 1;
				}
			}
			
			#subtitle {
				font-size: 11px;
				color: black;
				margin: 0 0 16px 0;
				line-height: 1.3;
			}
			
			.hidden {
				display: none !important;
			}
			
			.cloud-image {
				position: fixed;
				z-index: 150;
				pointer-events: none;
				transform-origin: center center;
				opacity: 1;
				filter: brightness(1.1) contrast(1.1);
			}
			
			.hud-scanner {
				position: fixed;
				width: 20px;
				height: 20px;
				border: 2px solid #4a90e2;
				background: rgba(74, 144, 226, 0.15);
				z-index: 160;
				pointer-events: none;
				transition: all 0.4s ease;
				box-shadow: 
					0 0 8px rgba(74, 144, 226, 0.4),
					inset 0 0 8px rgba(74, 144, 226, 0.2);
			}
			
			.hud-scanner.scanning {
				border-color: #2ecc71;
				background: rgba(46, 204, 113, 0.15);
				box-shadow: 
					0 0 15px rgba(46, 204, 113, 0.6),
					inset 0 0 10px rgba(46, 204, 113, 0.3);
			}
			
			.hud-scanner::before {
				content: '';
				position: absolute;
				top: 50%;
				left: 50%;
				width: 6px;
				height: 6px;
				background: currentColor;
				border-radius: 50%;
				transform: translate(-50%, -50%);
				box-shadow: 0 0 4px currentColor;
			}
			
			.hud-scanner::after {
				content: attr(data-status);
				position: absolute;
				bottom: -35px;
				right: -50px;
				font-family: 'Epmarugo', monospace;
				font-size: 10px;
				color: rgb(255, 255, 255);
				white-space: nowrap;
				font-weight: bold;
				text-shadow: 1px 1px 0px black, -1px -1px 0px black, 1px -1px 0px black, -1px 1px 0px black;
			}
			

			.hud-scanner-frame {
				position: absolute;
				top: -3px;
				left: -3px;
				right: -3px;
				bottom: -3px;
				border: 1px solid currentColor;
				opacity: 0.6;
				pointer-events: none;
			}
			
			.hud-scanner-corners {
				position: absolute;
				top: -6px;
				left: -6px;
				right: -6px;
				bottom: -6px;
				pointer-events: none;
			}
			
			.hud-scanner-corners::before,
			.hud-scanner-corners::after {
				content: '';
				position: absolute;
				width: 8px;
				height: 8px;
				border: 1px solid black;
				opacity: 0.8;
			}
			
			.hud-scanner-corners::before {
				top: 0;
				left: 0;
				border-right: none;
				border-bottom: none;
			}
			
			.hud-scanner-corners::after {
				bottom: 0;
				right: 0;
				border-left: none;
				border-top: none;
			}
		</style>
	</head>
	<body>
		<div id="homepage-ui">
			<div class="windows-dialog window">
				<div class="title-bar">
					<div class="title-bar-text">EX Research - Internet Culture Consultancy</div>
					<div class="title-bar-controls">
						<button aria-label="Minimize"></button>
						<button aria-label="Maximize"></button>
						<button aria-label="Close"></button>
					</div>
				</div>
				<div class="window-body">
					<h1 id="main-title">
						<span class="letter medium-light">EX</span>
						<span class="letter small">&nbsp;</span>
						<span class="letter medium">R</span><span class="letter medium">e</span><span class="letter medium">s</span><span class="letter medium">e</span><span class="letter medium">a</span><span class="letter medium">r</span><span class="letter medium">c</span><span class="letter medium">h</span>
					</h1>
					<p id="subtitle">EX Research helps you stay ahead of the internet.</p>
					<button id="enter-button">ENTER</button>
				</div>
			</div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';

			import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
			import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
			import { SAOPass } from 'three/addons/postprocessing/SAOPass.js';
			import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
			import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

			let container, stats;
			let camera, scene, renderer;
			let composer, renderPass, saoPass, ditheringPass;
			let group;
			let cloudBackground;
			let cloudRenderTarget, cloudRenderMaterial, cloudQuad, cloudScene, cloudCamera;
			
			// 2D Chatbox overlay variables
			let overlayCanvas, overlayCtx;
			let chatboxes2D = [];
			let customFontLoaded = false;
			let lastSpawnTime = 0;
			let spawnInterval = 1200; // Spawn new chatbox every 1.2 seconds (faster spawning)
			let pixelScale = 2; // How much to scale down for pixelation (higher = more pixelated)
			
			// Homepage elements
			let showHomepageUI = true;
			let enterButtonHovered = false;
			
			// Cloud image system
			let cloudImages = [];
			let lastCloudSpawnTime = 0; // Start at 0 so first cloud spawns immediately
			let cloudSpawnInterval = 3000; // Spawn every 3 seconds
			
			// Wandering HUD scanner system
			let wanderingScanners = [];
			let maxScanners = 3; // Number of autonomous scanners
			let detectionDistance = 80; // Distance at which scanners detect images
			
			// Intro sequence variables (disabled)
			let introStartTime = 0;
			let introPhase = 'normal'; // Start directly in normal mode
			let introDuration = 0; // No flooding
			let stragglerDuration = 0; // No stragglers
			let transitionDuration = 0; // No transition

			// Cloud shader
			const CloudShader = {
				uniforms: {
					'time': { value: 0.0 },
					'resolution': { value: new THREE.Vector2() }
				},

				vertexShader: `
					varying vec2 vUv;
					void main() {
						vUv = uv;
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					}
				`,

				fragmentShader: `
					uniform float time;
					uniform vec2 resolution;
					varying vec2 vUv;

					const float cloudscale = 0.8;
					const float speed = 0.02;
					const float clouddark = 0.4;
					const float cloudlight = 0.4;
					const float cloudcover = 0.3;
					const float cloudalpha = 6.0;
					const float skytint = 0.6;
					const vec3 skycolour1 = vec3(0.15, 0.3, 0.5);
					const vec3 skycolour2 = vec3(0.3, 0.6, 0.9);

					const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );

					vec2 hash( vec2 p ) {
						p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));
						return -1.0 + 2.0*fract(sin(p)*43758.5453123);
					}

					float noise( in vec2 p ) {
						const float K1 = 0.366025404; // (sqrt(3)-1)/2;
						const float K2 = 0.211324865; // (3-sqrt(3))/6;
						vec2 i = floor(p + (p.x+p.y)*K1);	
						vec2 a = p - i + (i.x+i.y)*K2;
						vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
						vec2 b = a - o + K2;
						vec2 c = a - 1.0 + 2.0*K2;
						vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
						vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
						return dot(n, vec3(70.0));	
					}

					float fbm(vec2 n) {
						float total = 0.0, amplitude = 0.1;
						for (int i = 0; i < 7; i++) {
							total += noise(n) * amplitude;
							n = m * n;
							amplitude *= 0.4;
						}
						return total;
					}

					void main() {
						vec2 p = vUv;
						vec2 uv = p*vec2(resolution.x/resolution.y,1.0);    
						float time = time * speed;
						float q = fbm(uv * cloudscale * 0.5);
						
						//ridged noise shape
						float r = 0.0;
						uv *= cloudscale;
						uv -= q - time;
						float weight = 0.8;
						for (int i=0; i<8; i++){
							r += abs(weight*noise( uv ));
							uv = m*uv + time;
							weight *= 0.7;
						}
						
						//noise shape
						float f = 0.0;
						uv = p*vec2(resolution.x/resolution.y,1.0);
						uv *= cloudscale;
						uv -= q - time;
						weight = 0.7;
						for (int i=0; i<8; i++){
							f += weight*noise( uv );
							uv = m*uv + time;
							weight *= 0.6;
						}
						
						f *= r + f;
						
						//noise colour
						float c = 0.0;
						time = time * speed * 2.0;
						uv = p*vec2(resolution.x/resolution.y,1.0);
						uv *= cloudscale*2.0;
						uv -= q - time;
						weight = 0.4;
						for (int i=0; i<7; i++){
							c += weight*noise( uv );
							uv = m*uv + time;
							weight *= 0.6;
						}
						
						//noise ridge colour
						float c1 = 0.0;
						time = time * speed * 3.0;
						uv = p*vec2(resolution.x/resolution.y,1.0);
						uv *= cloudscale*3.0;
						uv -= q - time;
						weight = 0.4;
						for (int i=0; i<7; i++){
							c1 += abs(weight*noise( uv ));
							uv = m*uv + time;
							weight *= 0.6;
						}
						
						c += c1;
						
						vec3 skycolour = mix(skycolour2, skycolour1, p.y);
						vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);
					   
						f = cloudcover + cloudalpha*f*r;
						
						vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));
						
						gl_FragColor = vec4( result, 1.0 );
					}
				`
			};

			// Dithering shader
			const DitheringShader = {
				uniforms: {
					'tDiffuse': { value: null },
					'resolution': { value: new THREE.Vector2() },
					'colorNum': { value: 12.0 },
					'pixelSize': { value: 2.0 }
				},

				vertexShader: `
					varying vec2 vUv;
					void main() {
						vUv = uv;
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					}
				`,

				fragmentShader: `
					uniform sampler2D tDiffuse;
					uniform vec2 resolution;
					uniform float colorNum;
					uniform float pixelSize;
					varying vec2 vUv;

					const float bayerMatrix8x8[64] = float[64](
						0.0/ 64.0, 48.0/ 64.0, 12.0/ 64.0, 60.0/ 64.0,  3.0/ 64.0, 51.0/ 64.0, 15.0/ 64.0, 63.0/ 64.0,
						32.0/ 64.0, 16.0/ 64.0, 44.0/ 64.0, 28.0/ 64.0, 35.0/ 64.0, 19.0/ 64.0, 47.0/ 64.0, 31.0/ 64.0,
						8.0/ 64.0, 56.0/ 64.0,  4.0/ 64.0, 52.0/ 64.0, 11.0/ 64.0, 59.0/ 64.0,  7.0/ 64.0, 55.0/ 64.0,
						40.0/ 64.0, 24.0/ 64.0, 36.0/ 64.0, 20.0/ 64.0, 43.0/ 64.0, 27.0/ 64.0, 39.0/ 64.0, 23.0/ 64.0,
						2.0/ 64.0, 50.0/ 64.0, 14.0/ 64.0, 62.0/ 64.0,  1.0/ 64.0, 49.0/ 64.0, 13.0/ 64.0, 61.0/ 64.0,
						34.0/ 64.0, 18.0/ 64.0, 46.0/ 64.0, 30.0/ 64.0, 33.0/ 64.0, 17.0/ 64.0, 45.0/ 64.0, 29.0/ 64.0,
						10.0/ 64.0, 58.0/ 64.0,  6.0/ 64.0, 54.0/ 64.0,  9.0/ 64.0, 57.0/ 64.0,  5.0/ 64.0, 53.0/ 64.0,
						42.0/ 64.0, 26.0/ 64.0, 38.0/ 64.0, 22.0/ 64.0, 41.0/ 64.0, 25.0/ 64.0, 37.0/ 64.0, 21.0 / 64.0
					);

					vec3 dither(vec2 uv, vec3 color) {
						int x = int(uv.x * resolution.x) % 8;
						int y = int(uv.y * resolution.y) % 8;
						float threshold = bayerMatrix8x8[y * 8 + x] - 0.25;

						color.rgb += threshold;
						color.r = floor(color.r * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);
						color.g = floor(color.g * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);
						color.b = floor(color.b * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);

						return color;
					}

					void main() {
						vec2 normalizedPixelSize = pixelSize / resolution;  
						vec2 uvPixel = normalizedPixelSize * floor(vUv / normalizedPixelSize);

						vec4 color = texture2D(tDiffuse, uvPixel);
						color.rgb = dither(uvPixel, color.rgb);

						gl_FragColor = color;
					}
				`
			};

			function createOverlayCanvas() {
				overlayCanvas = document.createElement('canvas');
				overlayCanvas.style.position = 'fixed'; // Use fixed instead of absolute
				overlayCanvas.style.top = '0';
				overlayCanvas.style.left = '0';
				overlayCanvas.style.pointerEvents = 'none';
				overlayCanvas.style.zIndex = '100';
				overlayCanvas.style.imageRendering = 'pixelated'; // Crisp pixel scaling
				overlayCanvas.style.imageRendering = 'crisp-edges'; // Fallback
				overlayCanvas.style.overflow = 'hidden'; // Prevent any overflow
				document.body.appendChild(overlayCanvas);
				
				overlayCtx = overlayCanvas.getContext('2d');
				// Disable antialiasing for crisp pixels
				overlayCtx.imageSmoothingEnabled = false;
				overlayCtx.webkitImageSmoothingEnabled = false;
				overlayCtx.mozImageSmoothingEnabled = false;
				overlayCtx.msImageSmoothingEnabled = false;
				
				resizeOverlayCanvas();
				
				// Load custom font
				loadCustomFont();
				
				// Create 2D chatboxes
				create2DChatboxes();
				
				// Setup homepage UI
				setupHomepageUI();
			}

			function loadCustomFont() {
				const font = new FontFace('Epmarugo', 'url(assets/epmarugo.ttf)');
				font.load().then(function(loadedFont) {
					document.fonts.add(loadedFont);
					customFontLoaded = true;
				}).catch(function(error) {
					console.warn('Custom font failed to load:', error);
					customFontLoaded = false;
				});
			}

			function resizeOverlayCanvas() {
				// Use viewport dimensions that exclude scrollbars
				const viewportWidth = document.documentElement.clientWidth;
				const viewportHeight = document.documentElement.clientHeight;
				
				// Set actual canvas size to lower resolution
				overlayCanvas.width = Math.floor(viewportWidth / pixelScale);
				overlayCanvas.height = Math.floor(viewportHeight / pixelScale);
				
				// Scale up the canvas display size to exact viewport
				overlayCanvas.style.width = viewportWidth + 'px';
				overlayCanvas.style.height = viewportHeight + 'px';
			}


			function setupHomepageUI() {
				const homepageUI = document.getElementById('homepage-ui');
				const enterButton = document.getElementById('enter-button');
				
				if (enterButton) {
					enterButton.addEventListener('click', function() {
						// Hide homepage UI
						homepageUI.classList.add('hidden');
						showHomepageUI = false;
						console.log('Welcome to EX Research!');
					});
				}
			}

			function create2DChatboxes() {
				// Start with some initial chatboxes already on screen
				chatboxes2D = [];
				
				// Create 8-12 initial chatboxes spread around the screen
				const initialCount = 8 + Math.floor(Math.random() * 5); // 8-12 chatboxes
				
				for (let i = 0; i < initialCount; i++) {
					const chatbox = createNewChatbox();
					// Better distribution - spread them more evenly across the screen
					const gridCols = Math.ceil(Math.sqrt(initialCount));
					const gridRows = Math.ceil(initialCount / gridCols);
					const col = i % gridCols;
					const row = Math.floor(i / gridCols);
					
					// Add some randomness to the grid positions
					const cellWidth = (overlayCanvas.width / pixelScale) / gridCols;
					const cellHeight = (overlayCanvas.height / pixelScale) / gridRows;
					
					chatbox.x = (col * cellWidth) + (Math.random() * cellWidth * 0.8);
					chatbox.y = (row * cellHeight) + (Math.random() * cellHeight * 0.8);
					
					// Make sure they stay within bounds
					chatbox.x = Math.max(0, Math.min(chatbox.x, overlayCanvas.width / pixelScale - chatbox.width));
					chatbox.y = Math.max(0, Math.min(chatbox.y, overlayCanvas.height / pixelScale - chatbox.height));
					
					chatboxes2D.push(chatbox);
				}
				
				console.log(`Created ${initialCount} initial chatboxes`);
			}

			function createNewChatbox(startX = null, speedTier = 'normal') {
				// Base dimensions that will appear consistent on screen regardless of pixelation
				const baseWidth = 240; // Target screen width in pixels
				const baseHeight = 72; // Target screen height in pixels
				
				// Scale dimensions inversely with pixelation to maintain consistent screen size
				const scaledWidth = baseWidth / pixelScale;
				const scaledHeight = baseHeight / pixelScale;
				const scaledMargin = 80 / pixelScale;
				
				const x = startX !== null ? startX : overlayCanvas.width + scaledMargin/4;
				const caretMargin = 20 / pixelScale; // medium margin only for caret
				const y = Math.random() * (overlayCanvas.height - scaledHeight - caretMargin);
				
				// Different speeds based on tier
				let baseVelocity, verticalDrift;
				switch (speedTier) {
					case 'superfast':
						// Lightning fast - the main rush
						baseVelocity = (-5 - Math.random() * 6) / pixelScale; // 5-11x faster
						verticalDrift = ((Math.random() - 0.5) * 1.5) / pixelScale; // Lots of vertical chaos
						break;
					case 'fast':
						// Fast but not crazy - part of the flood
						baseVelocity = (-3 - Math.random() * 3) / pixelScale; // 3-6x faster
						verticalDrift = ((Math.random() - 0.5) * 1.0) / pixelScale; // Some vertical movement
						break;
					case 'medium':
						// Medium speed - stragglers
						baseVelocity = (-1.5 - Math.random() * 2) / pixelScale; // 1.5-3.5x faster
						verticalDrift = ((Math.random() - 0.5) * 0.6) / pixelScale; // Moderate vertical
						break;
					case 'slow':
						// Slow stragglers - bridge to normal
						baseVelocity = (-0.8 - Math.random() * 1.2) / pixelScale; // 0.8-2x faster
						verticalDrift = ((Math.random() - 0.5) * 0.4) / pixelScale; // Little vertical
						break;
					default: // 'normal'
						// Normal mode: regular speed
						baseVelocity = (-0.5 - Math.random() * 0.8) / pixelScale;
						verticalDrift = ((Math.random() - 0.5) * 0.2) / pixelScale;
						break;
				}
				
				return {
					x: x,
					y: y,
					vx: baseVelocity,
					vy: verticalDrift,
					width: scaledWidth,
					height: scaledHeight,
					text: 'EX Research',
					textStyles: generateRandomTextStyles(), // Random styling for each chatbox
					styleUpdateTime: 0, // Track when to update styling
					speedTier: speedTier // Track what tier this chatbox is
				};
			}

			function generateRandomTextStyles() {
				// Simple "EX Research" with random styling
				const fragments = [
					{
						text: 'EX',
						bold: Math.random() > 0.5,
						sizeMultiplier: 0.8 + Math.random() * 0.6 // 0.8x to 1.4x size
					},
					{
						text: ' ',
						bold: false,
						sizeMultiplier: 1
					},
					{
						text: 'Research',
						bold: Math.random() > 0.5,
						sizeMultiplier: 0.8 + Math.random() * 0.6
					}
				];
				return fragments;
			}

			function createCloudImage() {
				const exNumber = Math.floor(Math.random() * 9) + 1; // 1-9
				const img = document.createElement('img');
				img.src = `assets/ex${exNumber}.png`;
				img.className = 'cloud-image';
				
				console.log(`Creating cloud image: ${img.src}`);
				
				// Random position
				const x = Math.random() * (window.innerWidth - 200) + 100;
				const y = Math.random() * (window.innerHeight - 200) + 100;
				
				// Random final size (ignoring aspect ratio)
				const finalWidth = 150 + Math.random() * 300; // 150-450px
				const finalHeight = 100 + Math.random() * 200; // 100-300px
				
				img.style.left = x + 'px';
				img.style.top = y + 'px';
				img.style.width = '0px';
				img.style.height = '0px';
				img.style.transform = 'translate(-50%, -50%)';
				
				img.onload = function() {
					console.log('Cloud image loaded successfully:', img.src);
				};
				
				img.onerror = function() {
					console.error('Failed to load cloud image:', img.src);
				};
				
				document.body.appendChild(img);
				console.log('Cloud image added to DOM at position:', x, y);
				
				const cloudData = {
					element: img,
					x: x,
					y: y,
					currentWidth: 0,
					currentHeight: 0,
					finalWidth: finalWidth,
					finalHeight: finalHeight,
					phase: 'scaling', // 'scaling', 'waiting', 'scanning', 'complete'
					startTime: performance.now(),
					scaleDuration: 200 + Math.random() * 300, // 0.2-0.5 seconds to scale (much faster!)
					scanner: null
				};
				
				return cloudData;
			}

			function createWanderingScanner() {
				const scanner = document.createElement('div');
				scanner.className = 'hud-scanner';
				
				// Add frame elements for cooler look
				const frame = document.createElement('div');
				frame.className = 'hud-scanner-frame';
				scanner.appendChild(frame);
				
				const corners = document.createElement('div');
				corners.className = 'hud-scanner-corners';
				scanner.appendChild(corners);
				
				const line = document.createElement('div');
				line.className = 'hud-scanner-line';
				scanner.appendChild(line);
				
				// Random starting position
				const startX = Math.random() * window.innerWidth;
				const startY = Math.random() * window.innerHeight;
				
				scanner.style.left = startX + 'px';
				scanner.style.top = startY + 'px';
				scanner.style.transform = 'translate(-50%, -50%)';
				scanner.style.width = '20px';
				scanner.style.height = '20px';
				scanner.setAttribute('data-status', 'Scanning');
				
				document.body.appendChild(scanner);
				
				// Random wandering direction and speed
				const angle = Math.random() * Math.PI * 2;
				const speed = 1 + Math.random() * 1.5; // 1-2.5 pixels per frame (normal patrol speed)
				
				const scannerData = {
					element: scanner,
					currentX: startX,
					currentY: startY,
					velocityX: Math.cos(angle) * speed,
					velocityY: Math.sin(angle) * speed,
					phase: 'wandering', // 'wandering', 'targeting', 'scanning', 'returning'
					lastDirectionChange: performance.now(),
					targetCloud: null,
					initialWidth: 20,
					initialHeight: 20
				};
				
				console.log('Created wandering scanner at', startX, startY);
				return scannerData;
			}

			function initializeWanderingScanners() {
				// Create initial set of wandering scanners
				for (let i = 0; i < maxScanners; i++) {
					wanderingScanners.push(createWanderingScanner());
				}
			}

			function updateCloudImages(currentTime) {
				// Update debug status
				if (window.cloudDebug) {
					const timeSinceSpawn = Math.round((currentTime - lastCloudSpawnTime) / 100) / 10;
					window.cloudDebug.status = `Next: ${Math.max(0, Math.round((cloudSpawnInterval - (currentTime - lastCloudSpawnTime)) / 100) / 10)}s, Active: ${cloudImages.length}, Enabled: ${window.cloudControls && window.cloudControls.enabled ? 'YES' : 'NO'}`;
				}
				
				// Debug logging
				if (currentTime % 1000 < 16) { // Log roughly every second
					console.log('Cloud spawn check:', {
						cloudControlsEnabled: window.cloudControls && window.cloudControls.enabled,
						showHomepageUI: showHomepageUI,
						introPhase: introPhase,
						timeSinceLastSpawn: currentTime - lastCloudSpawnTime,
						spawnInterval: cloudSpawnInterval
					});
				}
				
				// Spawn new cloud images (works on homepage too!)
				if (window.cloudControls && window.cloudControls.enabled && 
					currentTime - lastCloudSpawnTime > cloudSpawnInterval) {
					console.log('Auto-spawning new cloud image...');
					cloudImages.push(createCloudImage());
					lastCloudSpawnTime = currentTime;
				}
				
				// Update existing cloud images
				cloudImages = cloudImages.filter(cloud => {
					const elapsed = currentTime - cloud.startTime;
					
					if (cloud.phase === 'scaling') {
						// Scale up linearly
						const progress = Math.min(elapsed / cloud.scaleDuration, 1);
						cloud.currentWidth = cloud.finalWidth * progress;
						cloud.currentHeight = cloud.finalHeight * progress;
						
						cloud.element.style.width = cloud.currentWidth + 'px';
						cloud.element.style.height = cloud.currentHeight + 'px';
						
						if (progress >= 1) {
							cloud.phase = 'ready'; // Ready to be detected by wandering scanners
							// Immediately assign to nearest available scanner
							assignScannerToCloud(cloud);
						}
					} else if (cloud.phase === 'ready') {
						// Cloud is ready to be detected by wandering scanners
						// (No action needed here, wandering scanners will find it)
					} else if (cloud.phase === 'being_scanned') {
						// Cloud is being scanned, wait for completion
						// (Scanner handles its own lifecycle)
					}
					
					// Remove completed clouds
					return cloud.phase !== 'complete';
				});
			}

			function updateWanderingScanners(currentTime) {
				// Ensure we have the right number of scanners
				while (wanderingScanners.length < maxScanners) {
					wanderingScanners.push(createWanderingScanner());
				}
				
				wanderingScanners.forEach(scanner => {
					if (!scanner.element || !scanner.element.parentNode) return;
					
					if (scanner.phase === 'wandering') {
						// Random wandering behavior
						scanner.currentX += scanner.velocityX;
						scanner.currentY += scanner.velocityY;
						
						// Bounce off screen edges
						if (scanner.currentX < 0 || scanner.currentX > window.innerWidth) {
							scanner.velocityX *= -1;
							scanner.currentX = Math.max(0, Math.min(window.innerWidth, scanner.currentX));
						}
						if (scanner.currentY < 0 || scanner.currentY > window.innerHeight) {
							scanner.velocityY *= -1;
							scanner.currentY = Math.max(0, Math.min(window.innerHeight, scanner.currentY));
						}
						
						// Randomly change direction occasionally
						if (currentTime - scanner.lastDirectionChange > 2000 + Math.random() * 3000) {
							const angle = Math.random() * Math.PI * 2;
							const speed = 1 + Math.random() * 1.5; // Normal patrol speed
							scanner.velocityX = Math.cos(angle) * speed;
							scanner.velocityY = Math.sin(angle) * speed;
							scanner.lastDirectionChange = currentTime;
						}
						
						// Scanners are now assigned directly when clouds appear
						// No need for automatic detection
						
					} else if (scanner.phase === 'targeting') {
						// Move toward detected cloud
						const cloud = scanner.targetCloud;
						if (!cloud || cloud.phase === 'complete') {
							// Target lost, return to wandering
							scanner.phase = 'wandering';
							scanner.targetCloud = null;
							return;
						}
						
						const dx = cloud.x - scanner.currentX;
						const dy = cloud.y - scanner.currentY;
						const distance = Math.sqrt(dx * dx + dy * dy);
						
						if (distance > 5) {
							const moveSpeed = 10; // Much faster targeting speed
							scanner.currentX += (dx / distance) * moveSpeed;
							scanner.currentY += (dy / distance) * moveSpeed;
						} else {
							// Reached target, start scanning
							scanner.phase = 'scanning';
							scanner.scanStartTime = currentTime;
							scanner.growthStartTime = currentTime;
							scanner.targetWidth = cloud.finalWidth;
							scanner.targetHeight = cloud.finalHeight;
							scanner.element.classList.add('scanning');
							scanner.element.setAttribute('data-status', 'Identified');
							console.log(`Scanner analyzing cloud: ${scanner.targetWidth}x${scanner.targetHeight}`);
						}
						
					} else if (scanner.phase === 'scanning') {
						const elapsed = currentTime - scanner.scanStartTime;
						const growthElapsed = currentTime - scanner.growthStartTime;
						
						// Grow to match image size
						if (growthElapsed < 300) {
							const growthProgress = growthElapsed / 300;
							const easeProgress = 1 - Math.pow(1 - growthProgress, 3);
							
							const currentWidth = scanner.initialWidth + (scanner.targetWidth - scanner.initialWidth) * easeProgress;
							const currentHeight = scanner.initialHeight + (scanner.targetHeight - scanner.initialHeight) * easeProgress;
							
							scanner.element.style.width = currentWidth + 'px';
							scanner.element.style.height = currentHeight + 'px';
						}
						
						// Complete scan
						if (elapsed > 800) {
							// Remove cloud and reset scanner
							scanner.targetCloud.element.remove();
							scanner.targetCloud.phase = 'complete';
							
							// Reset scanner to wandering
							scanner.phase = 'returning';
							scanner.returnStartTime = currentTime;
							scanner.element.classList.remove('scanning');
							console.log('Scanner completed analysis, returning to patrol');
						}
						
					} else if (scanner.phase === 'returning') {
						// Shrink back to original size and resume wandering
						const elapsed = currentTime - scanner.returnStartTime;
						if (elapsed < 200) {
							const shrinkProgress = elapsed / 200;
							const currentWidth = scanner.targetWidth - (scanner.targetWidth - scanner.initialWidth) * shrinkProgress;
							const currentHeight = scanner.targetHeight - (scanner.targetHeight - scanner.initialHeight) * shrinkProgress;
							
							scanner.element.style.width = currentWidth + 'px';
							scanner.element.style.height = currentHeight + 'px';
						} else {
							// Return to wandering
							scanner.element.style.width = scanner.initialWidth + 'px';
							scanner.element.style.height = scanner.initialHeight + 'px';
							scanner.element.setAttribute('data-status', 'Scanning');
							scanner.phase = 'wandering';
							scanner.targetCloud = null;
							
							// New random direction
							const angle = Math.random() * Math.PI * 2;
							const speed = 1 + Math.random() * 1.5; // Normal patrol speed
							scanner.velocityX = Math.cos(angle) * speed;
							scanner.velocityY = Math.sin(angle) * speed;
						}
					}
					
					// Update visual position
					scanner.element.style.left = scanner.currentX + 'px';
					scanner.element.style.top = scanner.currentY + 'px';
				});
			}


			function assignScannerToCloud(cloud) {
				// Find the nearest available (wandering) scanner
				let nearestScanner = null;
				let nearestDistance = Infinity;
				
				wanderingScanners.forEach(scanner => {
					if (scanner.phase === 'wandering') {
						const dx = cloud.x - scanner.currentX;
						const dy = cloud.y - scanner.currentY;
						const distance = Math.sqrt(dx * dx + dy * dy);
						
						if (distance < nearestDistance) {
							nearestDistance = distance;
							nearestScanner = scanner;
						}
					}
				});
				
				if (nearestScanner) {
					// Assign this scanner to the cloud
					nearestScanner.phase = 'targeting';
					nearestScanner.targetCloud = cloud;
					cloud.phase = 'being_scanned';
					console.log('Assigned scanner to new cloud image');
				} else {
					console.log('No available scanners for new cloud');
				}
			}

			function drawChatboxes() {
				if (!overlayCtx) return;
				
				// Clear canvas
				overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
				
				const currentTime = performance.now();
				
				// Update cloud images
				updateCloudImages(currentTime);
				
				// Update wandering scanners
				updateWanderingScanners(currentTime);
				
				// Initialize intro timing
				if (introStartTime === 0) {
					introStartTime = currentTime;
				}
				
				// Determine current intro phase
				const timeSinceStart = currentTime - introStartTime;
				if (timeSinceStart < introDuration) {
					introPhase = 'flood';
				} else if (timeSinceStart < introDuration + stragglerDuration) {
					introPhase = 'stragglers';
				} else if (timeSinceStart < introDuration + stragglerDuration + transitionDuration) {
					introPhase = 'transition';
				} else {
					introPhase = 'normal';
				}
				
				const speed = window.chatboxControls ? window.chatboxControls.speed : 1.0;
				const connectionDistance = window.chatboxControls ? window.chatboxControls.connectionDistance * 12 : 40; // Scaled for low-res
				
				// Handle spawning based on intro phase
				if (introPhase === 'flood') {
					// Flood phase: massive wave of varied speed chatboxes
					if (currentTime - lastSpawnTime > 50) { // Every 50ms - very frequent
						// Spawn many chatboxes with varied speeds to completely cover screen
						for (let i = 0; i < 8; i++) { // 8 chatboxes every 50ms = 160 per second!
							let speedTier;
							const rand = Math.random();
							if (rand < 0.4) speedTier = 'superfast';      // 40% superfast
							else if (rand < 0.7) speedTier = 'fast';      // 30% fast  
							else speedTier = 'medium';                     // 30% medium
							
							chatboxes2D.push(createNewChatbox(null, speedTier));
						}
						lastSpawnTime = currentTime;
					}
				} else if (introPhase === 'stragglers') {
					// Straggler phase: fewer, slower chatboxes trickling through
					if (currentTime - lastSpawnTime > 200) { // Every 200ms
						// Spawn fewer stragglers with slower speeds
						for (let i = 0; i < 2; i++) {
							let speedTier;
							const rand = Math.random();
							if (rand < 0.3) speedTier = 'medium';         // 30% medium
							else if (rand < 0.7) speedTier = 'slow';      // 40% slow
							else speedTier = 'normal';                    // 30% normal
							
							chatboxes2D.push(createNewChatbox(null, speedTier));
						}
						lastSpawnTime = currentTime;
					}
				} else if (introPhase === 'transition') {
					// Transition phase: gradually slow down to normal spawning
					const transitionProgress = (timeSinceStart - introDuration - stragglerDuration) / transitionDuration;
					const currentSpawnRate = 200 + (spawnInterval - 200) * transitionProgress; // Lerp from 200ms to normal
					if (currentTime - lastSpawnTime > currentSpawnRate) {
						chatboxes2D.push(createNewChatbox(null, 'normal'));
						lastSpawnTime = currentTime;
					}
				} else {
					// Normal phase: regular spawning
					if (currentTime - lastSpawnTime > spawnInterval) {
						chatboxes2D.push(createNewChatbox(null, 'normal'));
						lastSpawnTime = currentTime;
					}
				}
				
				// Update positions and remove chatboxes that have left the screen
				chatboxes2D = chatboxes2D.filter(chatbox => {
					// Update position
					chatbox.x += chatbox.vx * speed;
					chatbox.y += chatbox.vy * speed;
					
					// Randomly update text styling every 2-4 seconds
					if (currentTime - chatbox.styleUpdateTime > 2000 + Math.random() * 2000) {
						chatbox.textStyles = generateRandomTextStyles();
						chatbox.styleUpdateTime = currentTime;
					}
					
					// Keep vertical position within bounds with soft bouncing (no margins)
					const caretMargin = 20 / pixelScale; // Small margin only for caret extending below
					if (chatbox.y < 0) {
						chatbox.y = 0;
						chatbox.vy = Math.abs(chatbox.vy) * 0.5; // Soft bounce down
					}
					if (chatbox.y > overlayCanvas.height - chatbox.height - caretMargin) {
						chatbox.y = overlayCanvas.height - chatbox.height - caretMargin;
						chatbox.vy = -Math.abs(chatbox.vy) * 0.5; // Soft bounce up
					}
					
					// Remove chatboxes that have moved off the left side
					return chatbox.x > -chatbox.width - 20;
				});
				
				// Draw connection lines
				overlayCtx.strokeStyle = 'black'; // Solid black
				overlayCtx.lineWidth = Math.max(1, Math.round(2 / pixelScale)); // Thin lines, scaled with pixelation
				
				for (let i = 0; i < chatboxes2D.length; i++) {
					for (let j = i + 1; j < chatboxes2D.length; j++) {
						const dx = (chatboxes2D[i].x + chatboxes2D[i].width/2) - (chatboxes2D[j].x + chatboxes2D[j].width/2);
						const dy = (chatboxes2D[i].y + chatboxes2D[i].height/2) - (chatboxes2D[j].y + chatboxes2D[j].height/2);
						const distance = Math.sqrt(dx * dx + dy * dy);
						
						if (distance < connectionDistance) {
							overlayCtx.beginPath();
							overlayCtx.moveTo(chatboxes2D[i].x + chatboxes2D[i].width/2, chatboxes2D[i].y + chatboxes2D[i].height/2);
							overlayCtx.lineTo(chatboxes2D[j].x + chatboxes2D[j].width/2, chatboxes2D[j].y + chatboxes2D[j].height/2);
							overlayCtx.stroke();
						}
					}
				}
				
				// Draw speech bubbles
				chatboxes2D.forEach(chatbox => {
					drawSpeechBubble(chatbox);
				});
			}

			function drawSpeechBubble(chatbox) {
				// Scale elements based on pixelation level to maintain consistent appearance
				const baseCaretSize = 20; // Base caret size for screen
				const baseCaretOffset = 32; // Base caret position offset
				
				const caretSize = baseCaretSize / pixelScale;
				const caretX = chatbox.x + (baseCaretOffset / pixelScale);
				const caretY = chatbox.y + chatbox.height;

				const isFF7Style = window.chatboxControls && window.chatboxControls.style === 'ff7';

				if (isFF7Style) {
					// FF7 Style: Deep blue gradient background
					const gradient = overlayCtx.createLinearGradient(
						chatbox.x, chatbox.y, 
						chatbox.x, chatbox.y + chatbox.height
					);
					gradient.addColorStop(0, '#1e3a5f'); // Lighter blue at top
					gradient.addColorStop(0.5, '#0f1f3d'); // Medium blue in middle  
					gradient.addColorStop(1, '#061426'); // Dark blue at bottom
					
					overlayCtx.fillStyle = gradient;
					overlayCtx.strokeStyle = '#4a6fa5'; // Light blue border
					overlayCtx.lineWidth = Math.max(1, Math.round(2 / pixelScale));
				} else {
					// Classic Style: White background with black border
					overlayCtx.fillStyle = 'white';
					overlayCtx.strokeStyle = 'black';
					overlayCtx.lineWidth = Math.max(1, Math.round(4 / pixelScale));
				}

				// First, fill both the box and caret as one shape
				overlayCtx.beginPath();
				// Main rectangle
				overlayCtx.rect(chatbox.x, chatbox.y, chatbox.width, chatbox.height);
				// Add caret triangle
				overlayCtx.moveTo(caretX - caretSize, caretY);
				overlayCtx.lineTo(caretX + caretSize, caretY);
				overlayCtx.lineTo(caretX, caretY + caretSize);
				overlayCtx.closePath();
				overlayCtx.fill();

				// Now stroke the box but skip the bottom section where caret connects
				overlayCtx.beginPath();
				// Top edge
				overlayCtx.moveTo(chatbox.x, chatbox.y);
				overlayCtx.lineTo(chatbox.x + chatbox.width, chatbox.y);
				// Right edge
				overlayCtx.lineTo(chatbox.x + chatbox.width, chatbox.y + chatbox.height);
				// Bottom edge - but skip the caret area
				overlayCtx.lineTo(caretX + caretSize, caretY);
				overlayCtx.moveTo(caretX - caretSize, caretY);
				overlayCtx.lineTo(chatbox.x, caretY);
				// Left edge
				overlayCtx.lineTo(chatbox.x, chatbox.y);
				overlayCtx.stroke();

				// Stroke only the outer edges of the caret
				overlayCtx.beginPath();
				overlayCtx.moveTo(caretX - caretSize, caretY);
				overlayCtx.lineTo(caretX, caretY + caretSize);
				overlayCtx.lineTo(caretX + caretSize, caretY);
				overlayCtx.stroke();
				
				// Draw text with random styling
				overlayCtx.fillStyle = isFF7Style ? 'white' : 'black';
				overlayCtx.textBaseline = 'middle';
				
				// Make font size relative to chatbox height (about 40% of height)
				const textBaseFontSize = chatbox.height * 0.4;
				const fontFamily = customFontLoaded ? 'Epmarugo' : 'monospace';
				
				// Calculate total text width to center it
				let totalWidth = 0;
				chatbox.textStyles.forEach(fragment => {
					const fontSize = textBaseFontSize * fragment.sizeMultiplier;
					const weight = fragment.bold ? 'bold' : 'normal';
					overlayCtx.font = `${weight} ${fontSize}px ${fontFamily}`;
					totalWidth += overlayCtx.measureText(fragment.text).width;
				});
				
				// Scale down text if it's too wide for the chatbox (leave some padding)
				const maxWidth = chatbox.width * 0.9; // 90% of chatbox width
				const textScale = totalWidth > maxWidth ? maxWidth / totalWidth : 1;
				
				// Start position for centered text
				let currentX = chatbox.x + (chatbox.width - (totalWidth * textScale)) / 2;
				const textY = chatbox.y + chatbox.height / 2;
				
				// Draw each fragment with its own styling
				chatbox.textStyles.forEach(fragment => {
					const fontSize = (textBaseFontSize * fragment.sizeMultiplier) * textScale;
					const weight = fragment.bold ? 'bold' : 'normal';
					overlayCtx.font = `${weight} ${fontSize}px ${fontFamily}`;
					
					overlayCtx.fillText(fragment.text, currentX, textY);
					currentX += overlayCtx.measureText(fragment.text).width;
				});
			}

			init();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				const width = document.documentElement.clientWidth;
				const height = document.documentElement.clientHeight;

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0x87CEEB, 1 ); // Sky blue background
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 65, width / height, 0.1, 20 );
				camera.position.z = 7;

				scene = new THREE.Scene();

				group = new THREE.Object3D();
				scene.add( group );

				// Create low-resolution cloud render target for performance
				const cloudRenderWidth = Math.floor(width / 4);  // 1/4 resolution for performance
				const cloudRenderHeight = Math.floor(height / 4);
				
				cloudRenderTarget = new THREE.WebGLRenderTarget(cloudRenderWidth, cloudRenderHeight);
				
				// Create cloud scene and camera for render target
				cloudScene = new THREE.Scene();
				cloudCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
				
				// Create cloud shader material for the render target
				const cloudShaderMaterial = new THREE.ShaderMaterial({
					uniforms: CloudShader.uniforms,
					vertexShader: CloudShader.vertexShader,
					fragmentShader: CloudShader.fragmentShader
				});
				
				// Create a full-screen quad for the cloud scene
				const cloudQuadGeometry = new THREE.PlaneGeometry(2, 2);
				const cloudQuadMesh = new THREE.Mesh(cloudQuadGeometry, cloudShaderMaterial);
				cloudScene.add(cloudQuadMesh);
				
				console.log('Cloud scene created with quad mesh');
				
				// Create a full-screen quad to display the cloud texture
				const quadGeometry = new THREE.PlaneGeometry(2, 2);
				cloudRenderMaterial = new THREE.ShaderMaterial({
					uniforms: {
						'cloudTexture': { value: cloudRenderTarget.texture }
					},
					vertexShader: `
						varying vec2 vUv;
						void main() {
							vUv = uv;
							gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
						}
					`,
					fragmentShader: `
						uniform sampler2D cloudTexture;
						varying vec2 vUv;
						void main() {
							vec4 cloudColor = texture2D(cloudTexture, vUv);
							// Add some debugging - if texture is black, show red
							if (cloudColor.r < 0.1 && cloudColor.g < 0.1 && cloudColor.b < 0.1) {
								gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Red for debugging
							} else {
								gl_FragColor = cloudColor;
							}
						}
					`
				});
				
				cloudQuad = new THREE.Mesh(quadGeometry, cloudRenderMaterial);
				cloudQuad.position.z = -5; // Behind everything else
				
				// Scale the quad to fill the screen properly
				const cameraDistance = 7;
				const fov = 65;
				const fovRad = (fov * Math.PI) / 180;
				const planeHeight = 2 * Math.tan(fovRad / 2) * cameraDistance;
				const planeWidth = planeHeight * (width / height);
				
				cloudQuad.scale.set(planeWidth / 2, planeHeight / 2, 1);
				scene.add(cloudQuad);
				
				console.log('Cloud quad scaled to:', planeWidth, 'x', planeHeight);
				
				// Set cloud shader resolution to the low resolution
				CloudShader.uniforms.resolution.value.set(cloudRenderWidth, cloudRenderHeight);
				
				console.log('Cloud render target created:', cloudRenderWidth, 'x', cloudRenderHeight);

				const light = new THREE.PointLight( 0xefffef, 500 );
				light.position.z = 10;
				light.position.y = - 10;
				light.position.x = - 10;
				scene.add( light );

				const light2 = new THREE.PointLight( 0xffefef, 500 );
				light2.position.z = 10;
				light2.position.x = - 10;
				light2.position.y = 10;
				scene.add( light2 );

				const light3 = new THREE.PointLight( 0xefefff, 500 );
				light3.position.z = 10;
				light3.position.x = 10;
				light3.position.y = - 10;
				scene.add( light3 );

				const light4 = new THREE.AmbientLight( 0xffffff, 0.2 );
				scene.add( light4 );

				const geometry = new THREE.SphereGeometry( 3, 48, 24 );

				for ( let i = 0; i < 120; i ++ ) {

					const material = new THREE.MeshStandardMaterial();
					material.roughness = 0.5 * Math.random() + 0.25;
					material.metalness = 0;
					material.color.setHSL( Math.random(), 1.0, 0.3 );

					const mesh = new THREE.Mesh( geometry, material );
					mesh.position.x = Math.random() * 4 - 2;
					mesh.position.y = Math.random() * 4 - 2;
					mesh.position.z = Math.random() * 4 - 2;
					mesh.rotation.x = Math.random();
					mesh.rotation.y = Math.random();
					mesh.rotation.z = Math.random();

					mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 0.2 + 0.05;
					group.add( mesh );

				}

				// Create 2D overlay canvas for chatboxes
				createOverlayCanvas();
				
				// Initialize wandering scanners
				initializeWanderingScanners();
				
				// Spawn initial cloud image immediately
				setTimeout(() => {
					if (cloudImages.length === 0) {
						cloudImages.push(createCloudImage());
						console.log('Spawned initial cloud image');
					}
				}, 100); // Small delay to ensure everything is initialized

				// stats = new Stats();
				// container.appendChild( stats.dom );

				composer = new EffectComposer( renderer );
				renderPass = new RenderPass( scene, camera );
				composer.addPass( renderPass );
				saoPass = new SAOPass( scene, camera );
				
				// Set default SAOPass parameters
				saoPass.params.output = SAOPass.OUTPUT.Default;
				saoPass.params.saoBias = 0.5;
				saoPass.params.saoIntensity = 0.42;
				saoPass.params.saoScale = 6;
				saoPass.params.saoKernelRadius = 100;
				saoPass.params.saoMinResolution = 0;
				saoPass.params.saoBlur = false;
				saoPass.params.saoBlurRadius = 8;
				saoPass.params.saoBlurStdDev = 4;
				saoPass.params.saoBlurDepthCutoff = 0.01;
				
				composer.addPass( saoPass );
				
				// Add dithering pass
				ditheringPass = new ShaderPass( DitheringShader );
				ditheringPass.uniforms.resolution.value.set( window.innerWidth, window.innerHeight );
				ditheringPass.enabled = true; // Dithering enabled
				composer.addPass( ditheringPass );
				
				const outputPass = new OutputPass();
				composer.addPass( outputPass );

				// Initialize default control values
				window.chatboxControls = {
					visible: true,
					speed: 2.0,
					connectionDistance: 12.0,
					spawnRate: 2.0,
					pixelation: 2,
					style: 'ff7' // 'classic' or 'ff7'
				};
				
				// Dithering controls
				window.ditheringControls = {
					enabled: true,
					colorLevels: 12,
					pixelSize: 2.0
				};

				window.cloudControls = {
					enabled: true,
					spawnRate: 0.5, // clouds per second
					scannerCount: 4
				};
				
				window.cloudDebug = {
					status: 'Waiting...'
				};

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				const width = document.documentElement.clientWidth || 1;
				const height = document.documentElement.clientHeight || 1;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();
				renderer.setSize( width, height );

				composer.setSize( width, height );
				
				// Update dithering pass resolution
				ditheringPass.uniforms.resolution.value.set( width, height );
				
				// Update cloud render target size
				const cloudRenderWidth = Math.floor(width / 4);
				const cloudRenderHeight = Math.floor(height / 4);
				
				cloudRenderTarget.setSize(cloudRenderWidth, cloudRenderHeight);
				CloudShader.uniforms.resolution.value.set(cloudRenderWidth, cloudRenderHeight);
				
				// Update cloud quad scaling for new aspect ratio
				if (cloudQuad) {
					const cameraDistance = 7;
					const fov = 65;
					const fovRad = (fov * Math.PI) / 180;
					const planeHeight = 2 * Math.tan(fovRad / 2) * cameraDistance;
					const planeWidth = planeHeight * (width / height);
					
					cloudQuad.scale.set(planeWidth / 2, planeHeight / 2, 1);
				}
				
				// Resize overlay canvas
				if ( overlayCanvas ) {
					resizeOverlayCanvas();
				}
				

			}

			function animate() {

				// stats.begin();
				render();
				// stats.end();

			}

			function render() {

				const timer = performance.now();
				group.rotation.x = timer * 0.0002;
				group.rotation.y = timer * 0.0001;
				
				// Update cloud shader time
				CloudShader.uniforms.time.value = timer * 0.001;
				
				// Update dithering parameters
				if (window.ditheringControls) {
					ditheringPass.enabled = window.ditheringControls.enabled;
					ditheringPass.uniforms.colorNum.value = window.ditheringControls.colorLevels;
					ditheringPass.uniforms.pixelSize.value = window.ditheringControls.pixelSize;
				}
				
				// Debug: Log cloud shader time every 5 seconds
				if (Math.floor(timer / 5000) !== Math.floor((timer - 16) / 5000)) {
					console.log('Cloud shader time:', CloudShader.uniforms.time.value);
				}

				// First, render clouds to the low-resolution render target
				renderer.setRenderTarget(cloudRenderTarget);
				renderer.clear();
				renderer.render(cloudScene, cloudCamera);
				
				// Note: Dithering will be applied to the main scene via the composer
				
				// Update the cloud texture in the main scene
				cloudRenderMaterial.uniforms.cloudTexture.value = cloudRenderTarget.texture;
				
				// Debug: Log every 5 seconds
				if (Math.floor(timer / 5000) !== Math.floor((timer - 16) / 5000)) {
					console.log('Rendering clouds to render target:', cloudRenderTarget.width, 'x', cloudRenderTarget.height);
					console.log('Cloud shader time:', CloudShader.uniforms.time.value);
				}
				
				// Reset render target to render to screen
				renderer.setRenderTarget(null);

				// Draw 2D chatboxes overlay
				if ( window.chatboxControls && window.chatboxControls.visible ) {
					drawChatboxes();
				}

				composer.render();

			}

		</script>
	</body>
</html>